"2023-01-01 01:00:00 EST",
"2023-01-01 02:00:00 EST",
"2023-01-01 01:05:00 EST",
"2023-01-01 02:05:00 EST"
))
ends <- starts + 10
event_ts <- sapply(1:length(starts), function(x){
return(seq(starts[x], ends[x], 0.5))
}, simplify = FALSE)
event_ts
test_that("The correct number and timing of discrete movement events are retained per pre-processing mode for RFID data and multiple temporal thresholds", {
# Avoid library calls and other changes to the virtual environment
# See https://r-pkgs.org/testing-design.html
withr::local_package("tidyverse")
withr::local_package("plyr")
withr::local_package("dplyr")
withr::local_package("lubridate")
withr::local_package("pbapply")
# Just for code development
# library(tidyverse)
# library(lubridate)
# library(testthat)
# Create a temporary directory for testing. Files will be written and read here
path <- "/home/gsvidaurre/Desktop"
data_dir <- "tmp_tests"
tmp_path <- file.path(path, data_dir)
if(!dir.exists(tmp_path)){
dir.create(tmp_path)
}
# Create the input data directory that the function expects
if(!dir.exists(file.path(tmp_path, "raw_combined"))){
dir.create(file.path(tmp_path, "raw_combined"))
}
# Create 4 clusters of detections: each cluster consists of a different number of detections spaced different numbers of seconds apart (testing `threshold`)
starts <- as.POSIXct(c(
"2023-01-01 01:00:00 EST",
"2023-01-01 02:00:00 EST",
"2023-01-01 01:05:00 EST",
"2023-01-01 02:05:00 EST"
))
ends <- starts + 10
ths <- seq(0.5, 5, by = 0.5)
invisible(lapply(1:length(ths), function(x){
# Create the timestamps
tmp_tstmps <- data.table::rbindlist(lapply(1:length(starts), function(i){
sim_ts <- seq(starts[i], ends[i], by = ths[x])
return(data.frame(tstmps = sim_ts, cluster = i))
}))
# Write out a spreadsheet with these timestamps that will be used as input data for the function
sim_ts <- data.frame(timestamp_ms = tmp_tstmps$tstmps) %>%
dplyr::mutate(
chamber_id = "Box_01",
year = year(timestamp_ms),
month = month(timestamp_ms),
day = day(timestamp_ms),
original_timestamp = gsub(" EST", "" , gsub("2023-01-01 ", "", timestamp_ms)),
sensor_id = "RFID",
data_type = "RFID",
data_stage = "raw_combined",
date_combined = Sys.Date(),
PIT_tag_ID = "test"
)
write.csv(sim_ts, file.path(tmp_path, "raw_combined", "combined_raw_data_RFID.csv"), row.names = FALSE)
####### `retain_first` mode #######
preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag_ID", pixel_col_nm = NULL, thin_threshold = ths[x], mode = "retain_first", pixel_threshold = NULL, drop_tag = NULL, path = path, data_dir = file.path(data_dir, "raw_combined"), out_dir = file.path(data_dir, "processed"), tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")
# Read in the output, check the output, then delete all files
test_res <- read.csv(file.path(tmp_path, "processed", "pre_processed_data_RFID.csv")) %>%
# Make sure the timestamps are in the right format
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
)
# Check that the results contain the expected number of detection clusters
expect_equal(nrow(test_res), length(starts))
# Check that each detection cluster is separated by more than the given temporal threshold
diffs <- test_res$timestamp_ms - lag(test_res$timestamp_ms)
diffs <- diffs[!is.na(diffs)]
expect_true(all(diffs >= ths[x]))
# Check that the first timestamp from the raw data is returned as the timestamp per detection cluster
tmp_starts <- starts[order(starts)]
invisible(lapply(1:nrow(test_res), function(z){
expect_equal(test_res$timestamp_ms[z], tmp_starts[z])
}))
####### `thin` mode #######
preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag_ID", pixel_col_nm = NULL, thin_threshold = ths[x], mode = "thin", pixel_threshold = NULL, drop_tag = NULL, path = path, data_dir = file.path(data_dir, "raw_combined"), out_dir = file.path(data_dir, "processed"), tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")
# Read in the output, check the output, then delete all files
test_res <- read.csv(file.path(tmp_path, "processed", "pre_processed_data_RFID.csv")) %>%
# Make sure the timestamps are in the right format
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
)
# Check that the results contain the expected number of detections. This should be the number of total clusters by the number of detections expected per cluster using mode = 'thin'
# cat("thin mode: th = ", ths[x], "\n")
num_seq <- seq(starts[1], ends[1], by = ths[x])
expect_equal(nrow(test_res), length(starts) * length(seq(1, length(num_seq), 2)))
# Check that detections are separated by more than the given temporal threshold
diffs <- test_res$timestamp_ms - lag(test_res$timestamp_ms)
diffs <- diffs[!is.na(diffs)]
expect_true(all(diffs >= ths[x]))
# Check that the every other timestamp from the raw data is returned as the timestamp per detection cluster
tmp_tstmps <- data.table::rbindlist(lapply(1:length(starts), function(i){
sim_ts <- seq(starts[i], ends[i], by = ths[x])
if(length(sim_ts) %% 2 != 0){
sim_ts <- sim_ts[-seq(2, length(sim_ts) - 1, 2)]
} else if(length(sim_ts) %% 2 == 0){
sim_ts <- sim_ts[-seq(2, length(sim_ts), 2)]
}
return(data.frame(tstmps = sim_ts, cluster = i))
}))
tmp_tstmps$tstmps <- tmp_tstmps$tstmps[order(tmp_tstmps$tstmps)]
expect_equal(test_res$timestamp_ms, tmp_tstmps$tstmps)
}))
# Remove the temporary directory and all files within it
if(tmp_path == file.path(path, data_dir)){
unlink(tmp_path, recursive = TRUE)
}
})
library(tidyverse)
library(lubridate)
library(testthat)
# Create a temporary directory for testing. Files will be written and read here
path <- "/home/gsvidaurre/Desktop"
data_dir <- "tmp_tests"
tmp_path <- file.path(path, data_dir)
if(!dir.exists(tmp_path)){
dir.create(tmp_path)
}
# Create the input data directory that the function expects
if(!dir.exists(file.path(tmp_path, "raw_combined"))){
dir.create(file.path(tmp_path, "raw_combined"))
}
# Create 4 clusters of detections: each cluster consists of a different number of detections spaced different numbers of seconds apart (testing `threshold`)
starts <- as.POSIXct(c(
"2023-01-01 01:00:00 EST",
"2023-01-01 02:00:00 EST",
"2023-01-01 01:05:00 EST",
"2023-01-01 02:05:00 EST"
))
ends <- starts + 10
ths <- seq(0.5, 5, by = 0.5)
ths
invisible(lapply(1:length(ths), function(x){
# Create the timestamps
tmp_tstmps <- data.table::rbindlist(lapply(1:length(starts), function(i){
sim_ts <- seq(starts[i], ends[i], by = ths[x])
return(data.frame(tstmps = sim_ts, cluster = i))
}))
# Write out a spreadsheet with these timestamps that will be used as input data for the function
sim_ts <- data.frame(timestamp_ms = tmp_tstmps$tstmps) %>%
dplyr::mutate(
chamber_id = "Box_01",
year = year(timestamp_ms),
month = month(timestamp_ms),
day = day(timestamp_ms),
original_timestamp = gsub(" EST", "" , gsub("2023-01-01 ", "", timestamp_ms)),
sensor_id = "RFID",
data_type = "RFID",
data_stage = "raw_combined",
date_combined = Sys.Date(),
PIT_tag_ID = "test"
)
write.csv(sim_ts, file.path(tmp_path, "raw_combined", "combined_raw_data_RFID.csv"), row.names = FALSE)
####### `retain_first` mode #######
preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag_ID", pixel_col_nm = NULL, thin_threshold = ths[x], mode = "retain_first", pixel_threshold = NULL, drop_tag = NULL, path = path, data_dir = file.path(data_dir, "raw_combined"), out_dir = file.path(data_dir, "processed"), tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")
# Read in the output, check the output, then delete all files
test_res <- read.csv(file.path(tmp_path, "processed", "pre_processed_data_RFID.csv")) %>%
# Make sure the timestamps are in the right format
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
)
# Check that the results contain the expected number of detection clusters
expect_equal(nrow(test_res), length(starts))
# Check that each detection cluster is separated by more than the given temporal threshold
diffs <- test_res$timestamp_ms - lag(test_res$timestamp_ms)
diffs <- diffs[!is.na(diffs)]
expect_true(all(diffs >= ths[x]))
# Check that the first timestamp from the raw data is returned as the timestamp per detection cluster
tmp_starts <- starts[order(starts)]
invisible(lapply(1:nrow(test_res), function(z){
expect_equal(test_res$timestamp_ms[z], tmp_starts[z])
}))
####### `thin` mode #######
preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag_ID", pixel_col_nm = NULL, thin_threshold = ths[x], mode = "thin", pixel_threshold = NULL, drop_tag = NULL, path = path, data_dir = file.path(data_dir, "raw_combined"), out_dir = file.path(data_dir, "processed"), tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")
# Read in the output, check the output, then delete all files
test_res <- read.csv(file.path(tmp_path, "processed", "pre_processed_data_RFID.csv")) %>%
# Make sure the timestamps are in the right format
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
)
# Check that the results contain the expected number of detections. This should be the number of total clusters by the number of detections expected per cluster using mode = 'thin'
# cat("thin mode: th = ", ths[x], "\n")
num_seq <- seq(starts[1], ends[1], by = ths[x])
expect_equal(nrow(test_res), length(starts) * length(seq(1, length(num_seq), 2)))
# Check that detections are separated by more than the given temporal threshold
diffs <- test_res$timestamp_ms - lag(test_res$timestamp_ms)
diffs <- diffs[!is.na(diffs)]
expect_true(all(diffs >= ths[x]))
# Check that the every other timestamp from the raw data is returned as the timestamp per detection cluster
tmp_tstmps <- data.table::rbindlist(lapply(1:length(starts), function(i){
sim_ts <- seq(starts[i], ends[i], by = ths[x])
if(length(sim_ts) %% 2 != 0){
sim_ts <- sim_ts[-seq(2, length(sim_ts) - 1, 2)]
} else if(length(sim_ts) %% 2 == 0){
sim_ts <- sim_ts[-seq(2, length(sim_ts), 2)]
}
return(data.frame(tstmps = sim_ts, cluster = i))
}))
tmp_tstmps$tstmps <- tmp_tstmps$tstmps[order(tmp_tstmps$tstmps)]
expect_equal(test_res$timestamp_ms, tmp_tstmps$tstmps)
}))
x <- 1
# Create the timestamps
tmp_tstmps <- data.table::rbindlist(lapply(1:length(starts), function(i){
sim_ts <- seq(starts[i], ends[i], by = ths[x])
return(data.frame(tstmps = sim_ts, cluster = i))
}))
tmp_tstmps
ths
x <- 4
# Create the timestamps
tmp_tstmps <- data.table::rbindlist(lapply(1:length(starts), function(i){
sim_ts <- seq(starts[i], ends[i], by = ths[x])
return(data.frame(tstmps = sim_ts, cluster = i))
}))
tmp_tstmps
# Write out a spreadsheet with these timestamps that will be used as input data for the function
sim_ts <- data.frame(timestamp_ms = tmp_tstmps$tstmps) %>%
dplyr::mutate(
chamber_id = "Box_01",
year = year(timestamp_ms),
month = month(timestamp_ms),
day = day(timestamp_ms),
original_timestamp = gsub(" EST", "" , gsub("2023-01-01 ", "", timestamp_ms)),
sensor_id = "RFID",
data_type = "RFID",
data_stage = "raw_combined",
date_combined = Sys.Date(),
PIT_tag_ID = "test"
)
write.csv(sim_ts, file.path(tmp_path, "raw_combined", "combined_raw_data_RFID.csv"), row.names = FALSE)
preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag_ID", pixel_col_nm = NULL, thin_threshold = ths[x], mode = "retain_first", pixel_threshold = NULL, drop_tag = NULL, path = path, data_dir = file.path(data_dir, "raw_combined"), out_dir = file.path(data_dir, "processed"), tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")
# Read in the output, check the output, then delete all files
test_res <- read.csv(file.path(tmp_path, "processed", "pre_processed_data_RFID.csv")) %>%
# Make sure the timestamps are in the right format
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
)
# Check that the results contain the expected number of detection clusters
expect_equal(nrow(test_res), length(starts))
nrow(test_res)
length(starts)
View(test_res)
# Check that each detection cluster is separated by more than the given temporal threshold
diffs <- test_res$timestamp_ms - lag(test_res$timestamp_ms)
diffs <- diffs[!is.na(diffs)]
diffs
expect_true(all(diffs >= ths[x]))
# Check that the first timestamp from the raw data is returned as the timestamp per detection cluster
tmp_starts <- starts[order(starts)]
tmp_starts
invisible(lapply(1:nrow(test_res), function(z){
expect_equal(test_res$timestamp_ms[z], tmp_starts[z])
}))
####### `thin` mode #######
preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag_ID", pixel_col_nm = NULL, thin_threshold = ths[x], mode = "thin", pixel_threshold = NULL, drop_tag = NULL, path = path, data_dir = file.path(data_dir, "raw_combined"), out_dir = file.path(data_dir, "processed"), tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")
# Read in the output, check the output, then delete all files
test_res <- read.csv(file.path(tmp_path, "processed", "pre_processed_data_RFID.csv")) %>%
# Make sure the timestamps are in the right format
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
)
View(test_res)
rfid_raw <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_RFID.csv")) %>%
# The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
) %>%
dplyr::arrange(-desc(timestamp_ms))
rm(list = ls()) # Clean global environment
library(tidyverse) # Load the set of tidyverse packages
library(data.table) # Load other packages that the ABISSMAL functions require
# Initialize an object with the path that is your working directory
path <- "/home/gsvidaurre/Desktop/ABISSMAL_vignettes"
# Load the function that combines raw data
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/combine_raw_data.R")
# Load the function that detects perching events in the raw data
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/detect_perching_events.R")
# Load the function that pre-processes raw data
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/preprocess_detections.R")
# Load a script with utility functions that each function above requires
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/utilities.R")
rfid_raw <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_RFID.csv")) %>%
# The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
) %>%
dplyr::arrange(-desc(timestamp_ms))
# You should see that the timestamp_ms is in "dttm" format, which means that the POSIX conversion was done correctly
glimpse(rfid_raw)
rfid_pp <- read.csv(file.path(path, "Data/processed/pre_processed_data_RFID.csv")) %>%
# The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
) %>%
dplyr::arrange(-desc(timestamp_ms))
glimpse(rfid_pp)
View(cbind(rfid_raw$timestamp_ms, rfid_pp$timestamp_ms))
View(data.frame(rfid_raw$timestamp_ms, rfid_pp$timestamp_ms))
rfid_raw$timestamp_ms
View(data.frame(rfid_raw$timestamp_ms[1:20], rfid_pp$timestamp_ms[1;20]))
View(data.frame(rfid_raw$timestamp_ms[1:20], rfid_pp$timestamp_ms[1:20]))
View(data.frame(rfid_raw$timestamp_ms[1:25], rfid_pp$timestamp_ms[1:25]))
ggplot(data = rfid_combined %>%
group_by(dataset) %>%
slice(1:5) %>%
ungroup()
) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "right")
rfid_combined <- rfid_raw %>%
dplyr::select(sensor_id, day, timestamp_ms) %>%
dplyr::mutate(
dataset = "raw"
) %>%
bind_rows(
rfid_pp %>%
dplyr::select(sensor_id, day, timestamp_ms) %>%
dplyr::mutate(
dataset = "pre-processed"
)
)
glimpse(rfid_combined)
# Change the column dataset to data type "factor"
# By specifying "raw" first in the argument levels, you are reordering the factor levels so that "raw" comes first
rfid_combined <- rfid_combined %>%
dplyr::mutate(
dataset = factor(dataset, levels = c("raw", "pre-processed"))
)
# The dataset column is now type "fct", or "factor"
glimpse(rfid_combined)
# The levels of the factor column are ordered with "raw" first, rather than in alphabetical order
levels(rfid_combined$dataset)
ggplot(data = rfid_combined %>%
group_by(dataset) %>%
slice(1:5) %>%
ungroup()
) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "right")
ggplot(data = rfid_combined %>%
group_by(dataset) %>%
slice(1:3) %>%
ungroup()
) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "right")
ggplot(data = rfid_combined %>%
group_by(dataset) %>%
slice(1:4) %>%
ungroup()
) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "right")
ggplot(data = rfid_combined %>%
group_by(dataset) %>%
slice(1:3) %>%
ungroup()
) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "right")
ggplot(data = rfid_combined) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "right")
rfid_perch <- read.csv(file.path(path, "Data/processed/perching_events_RFID.csv")) %>%
# The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
dplyr::mutate(
timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
) %>%
dplyr::arrange(-desc(timestamp_ms))
rfid_perch <- read.csv(file.path(path, "Data/processed/perching_events_RFID.csv")) %>%
# The start and end timestamps must be converted to POSIX format every time that the data is read back into R for plotting
dplyr::mutate(
perching_start = as.POSIXct(format(as.POSIXct(perching_start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
perching_end = as.POSIXct(format(as.POSIXct(perching_end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
) %>%
dplyr::arrange(-desc(perching_start))
glimpse(rfid_perch)
ggplot(data = rfid_combined) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "left")
ggplot(data = rfid_combined) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "left") +
# Add the perching events to the plot
geom_segment(
data = rfid_perch,
aes(x = perching_start, xend = perching_end, y = 0, yend = 1),
color = "blue",
linewidth = 0.3
)
ggplot(data = rfid_combined) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "left") +
# Add the perching events to the plot
geom_segment(
data = rfid_perch,
aes(x = perching_start, xend = perching_end, y = 1, yend = 1.5),
color = "blue",
linewidth = 0.3
)
ggplot(data = rfid_combined) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "left") +
# Add the perching events to the plot
geom_segment(
data = rfid_perch,
aes(x = perching_start, xend = perching_end, y = 1.2, yend = 1.5),
color = "blue",
linewidth = 0.3
)
gg <- ggplot(data = rfid_combined) +
# Add a vertical line for each timestamp
geom_segment(
aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1, color = dataset),
linewidth = 0.3
) +
scale_color_manual(values = c("orange", "darkgreen")) +
# ~ is equivalent to "by", so that you're creating panels by the unique values in the column dataset
facet_wrap(~ dataset, nrow = 2, strip.position = "left") +
# Add the perching events to the plot
geom_segment(
data = rfid_perch,
aes(x = perching_start, xend = perching_end, y = 1.2, yend = 1.5),
color = "blue",
linewidth = 0.3
) +
theme(
legend.position = "top"
)
gg
gg <- gg +
# Change the x and y axis labels
xlab("Date and time") +
# The y-axis does not contain information right now, so it can be blank
ylab("") +
# Use this function to convert the plot background to black and white
theme_bw() +
# Use aesthetics functions to remove the y-axis labels and ticks
theme(
axis.text.y = element_blank(),
axis.ticks.y = element_blank()
)
gg
