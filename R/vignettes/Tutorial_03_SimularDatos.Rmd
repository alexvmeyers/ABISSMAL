---
title: "Tutorial 03: Simular Datos"
author: "Grace Smith-Vidaurre"
date: "2023-12-27"
output: 
  html_document:
    css: "styles.css"
    toc: true
    toc_float: true
    toc_depth: 4
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

<h2>Información sobre esta traducción</h2>

Este tutorial fue traducido al español por Grace Smith-Vidaurre, siguiendo las [convenciones de traducción de los Carpentries](https://github.com/Carpentries-ES/board/blob/master/Convenciones_Traduccion.md), incluyendo usar el género femenino por defecto. Si encuentras errores de ortografía que impiden tu habilidad de completar los tutoriales, por favor reporta los errores de ortografía a GitHub usando los pasos arriba para reportar un "Issue".

<h2>Resumen del tutorial y objetivos de aprendizaje</h2>

En este tercer tutorial, vamos a crear datos simulados de moviemientos de animals que fueron detectados por diferentes sensores. El proceso de simular estos datos reemplaza el proceso de coleccion de datos que provee ABISSMAL para grabar datos de animales en vivo. Generar estos datos simulados te va a proveer mas oportunidades para practicar habilidades basicas de escribir codigo y tener control sobre la creacion de estos datos te ayudara entender los pasos diferentes de analisis de datos que siguen. Si quieres ver datos recolectados de pajaros con el software de ABISSMAL, y el codigo que fue usado para analizar esos datos, puedes revisar el preprint del [manuscrito de metodos](https://ecoevorxiv.org/repository/view/6268/) que tiene enlaces a los datos y el codigo que son publicamente acesibles.

A traves del proceso de simular datos en este tutorial, vas a continuar usando habilidades de programacion que aprendiste en el segundo tutorial, y vas a aprender habilidades adicionales que incluyen:

1. Crear objetos como vectores y `dataframes`
2. Tipos de datos en R
3. Indexar y manipular objetos
4. Usar frases condicionales
5. Expresiones de `pipe` en el `tidyverse`

<h2>Cargar paquetes</h2>

En el tutorial anterior instalaste el `tidyverse`, una coleccion de paquetes para la ciencia de datos. Tambien aprendiste sobre directorios de trabajo y creaste un directorio nuevo en tu computadora para guardar archivos de datos o imagenes que vas a generar en los siguientes tutoriales.

Cada vez que inicies un archivo nuevo de RMarkdown o R, es importante configurar tu espacio virtual antes de empezar a analizar datos. En el trozo abajo, vas a limpiar tu ambiente global y cargar el `tidyverse` usando codigo que viste en el segundo tutorial, pero ahora todo el codigo esta combinado en un solo trozo.
```{r message = FALSE, warning = FALSE}

rm(list = ls()) # Limpia tu ambiente global

library(tidyverse) # Carga la coleccion de paquetes en el tidyverse

```

<h2>Crear un objeto de `path`</h2>

El siguiente paso sera especificar tu directorio de trabajo. En el segundo tutorial, usaste un `string`, o una secuencia de caracteres entrecomillas para indicar texto adentro de codigo de R, para especificar el `path` de tu directorio de trabajo mientras usabas funciones diferentes. En vez de copiar y pegar la misma secuencia de caracteres cada vez que quieres usar este `path`, es mas eficiente guardar esta secuencia de caracteres (que especifica el `path` de tu directorio de trabajo) adentro de un objeto nuevo, y luego usar el nombre del objeto cuando necesitas especificar el `path`.

Para crear un objeto de tu `path`, puedes escribir el nombre del objeto que quieres crear al lado izquierdo del trozo (sin comillas), luego los simbolos para crear un objeto en R (`<-`), y luego la informacion que quieres asignar a este objeto. En este case, la informacion que quieres guardar adentro de este objeto es tu directorio de trabajo en el formato de un `string`, y esta informacion necesita estar entrecomillas.
```{r eval = TRUE}

path <- "/home/gsvidaurre/Desktop/ABISSMAL_tutoriales"

```

En el codigo arriba, creaste un objeto que se llama `path`. Puedes ver la informacion que contiene este objeto con escribir el nombre del objeto y ejecutar ese codigo en la consola:
```{r eval = TRUE}

path

```

Tambien puedes ver el contenido de `path` con hacer clic en la pestana de "Environment" y revisar la columna al lado derecho del nombre del objeto. Ahora puedes confirmar que `path` es un objeto nuevo que contiene informacion sobre tu directorio de trabajo y esta disponible en tu ambiente global para mas operaciones.

Puedes practicar eliminar solamente el objeto `path` de tu ambiente global con escribir y ejecutar el codigo `rm(list = "path")`. Despues de ejecutar este codigo, deberias de inicializar `path` otra vez usando el codigo arriba.

<h2>Crear marcas de tiempo para detecciones simuladas de movimientos</h2>

Los datos primarios que colecta ABISSMAL son marcas de tiempo que indican el momento en el tiempo cuando un sensor se activo y grabo movimiento. Muchas (pero no todas) de estas detecciones se pueden asignar a uno o mas animales que se movieron cerca de un sensor, por ejemplo, cuando un pajaro entra a un contenedor de nido a traves de una antena circular de RFID ("radio frequency identification") montado en la entrada del contenedor. En los siguientes trozos de codigo, vamos a generar datos simulados que representan datos de detecciones grabados por el sensor de RFID y tambien sensores de infrarrojo.

Digamos que estamos recolectando datos para 2 pajaros adultos a traves de sensores de ABISSMAL montados en un contenedor de nido. La antena de RFID esta montada en la entrada del contenedor, y un par de sensores de infrarrojo, el par "externo", esta montado en frente de la antena de RFID para capturar movimientos afuera de la entrada del contenedor. Un segundo par de sensores de infrarrojo, el par "interno", esta montado detras de la antena de RFID para capturar movimientos adentro de la entrada del contenedor. En este ejemplo simulado, el par externo de sensores infrarrojo va a activar cuando un pajaro entra al contenedor de nido, luego la antena de RFID, y luego el par interno de sensores infrarrojos. Cuando un pajaro sale del contenedor, el par interno de sensores infrarrojos deberia de activar primero, luego la antena de RFID, y luego el par externo de sensores infrarrojos.

Empezaremos con crear un objeto que contiene las marcas de tiempo simuladas para la antena de RFID. Este objecto se llamara `rfid_ts` y va a contener cuatro marcas de tiempo en formato de horas:minutos:segundos. Cada marca de tiempo estara entrecomillas para indicar que estamos usando informacion de text o secuencia de caracteres en el formato `string` de R.

Vas a combinar estas marcas de tiempo adentro de un solo objeto usando la funcion `c()`. Esta function concatena valores separados por comas en un objecto de tipo vector o lista. Arriba creaste un objeto que se llama `path` sin usar `c()`, pero este objeto tenia un solo valor o elemento. Usar `c()` facilita combinar multiple valores en un objeto como un vector que puede tener multiple elementos.
```{r}

# Crea un vector de cuatro marcas de tiempo de RFID o cuatro elementos in formato HH:MM:SS
rfid_ts <- c("10:00:00", "10:05:00", "11:00:00", "11:05:00")
  
```

Puedes ver las propiedades diferentes del objeto `rfid_ts`:
```{r}

rfid_ts # Ejecuta el nombre del objeto para ver sus contenidos

is.vector(rfid_ts) # Un valor binario indica si rfid_ts es un vector (TRUE) o no (FALSE)

class(rfid_ts) # Un vector de tipo de dato `character` en R, o tipo `string`

length(rfid_ts) # Este vector tiene cuatro elementos

```

Continuemos por simular dos movimientos de entrada y dos movimientos de salida del contenedor. Podemos escoger marcas de tiempo para el par externo de sensores de infrarrojo que preceden las marcas de tiempo de RFID y marcas de tiempo del par interno de sensores infrarrojo que siguen las marcas de tiempo de RFID para simular un evento de entrada. Podemos simular eventos de salida con las marcas de tiempo en el orden opuesto (el par interno de sensores se activa primero, luego RFID, luego el par externo de sensores de infrarrojo). Vamos a separar las detecciones de cada sensor adentro de cada movimiento de entrada y salida por un segundo.
```{r}

# Simula marcas de tiempo para el par externo ("o_") e interno ("i_") de sensores infrarrojo para una entrada, una salida, y luego otra entrada y salida
o_irbb_ts <- c("09:59:59", "10:05:01", "10:59:59", "11:05:01") # externo
i_irbb_ts <- c("10:00:01", "10:04:59", "11:00:01", "11:04:59") # interno

```

Los pajaros a veces posan en la entrada del contenedor usando la antena de RFID como percha, y los sensores deberian de colectar datos sobre este comportamiento. Puedes anadir eventos de posar a los datos simulados, y aqui vas a simular eventos de posar solamente con los datos de RFID.
```{r}

rfid_ts <- c(rfid_ts, "08:00:00", "08:00:01", "08:00:02", "08:00:03", "11:30:00", "11:30:01", "11:30:02", "11:30:03", "11:30:04", "11:30:05")

```

En el codigo arriba, modificaste el objeto `rfid_ts` con la funcion `c()` para anadir diez mas marcas de tiempo a este vector para tener un total de 14 elementos. Revisa la estructura del objeto modificado de `rfid_ts` usando la funcion `glimpse()`:
```{r}

# Aqui puedes ver la estructura del objeto en un formato que incluye el tipo de dato en R ("chr", que es tipo `character` o `string`), el numero de elementos ([1:14]), y los valores de los primeros elementos del vector
glimpse(rfid_ts)

```

Otro tipo de informacion importante es simular ruido en las detecciones de los sensores. Por ejemplo, la antena de RFID puede fallar en detectar la etiqueta PIT ("passive integrated transponder") de un individuo, y los sensores de infrarrojo pueden activarse cuando los pajaros dejan materal de nido colgando en la entrada del contenedor. En ambos casos, los sensores infrarrojos deberian de activar pero no la antena de RFID.
```{r}

# Simula unas fallas de deteccion de la antena de RFID a traves de ambos pares de sensore infrarrojos
# Estas fallas en deteccion del sensor de RFID surgio en cuatro eventos simulados adicionales (dos entradas y dos salidas)
o_irbb_ts <- c(o_irbb_ts, "06:05:05", "06:35:08", "07:15:40", "11:10:25")
i_irbb_ts <- c(i_irbb_ts, "06:05:04", "06:35:09", "07:15:41", "11:10:24")

glimpse(o_irbb_ts)
glimpse(i_irbb_ts)

# Luego simula unas detecciones de ruido para el par externo de sensores infrarrojo
o_irbb_ts <- c(o_irbb_ts, "09:45:01", "09:45:02", "09:45:03", "09:45:04", "09:45:05", "09:45:06", "09:45:07", "09:45:08", "09:45:09", "09:45:10", "09:45:11")

glimpse(o_irbb_ts)

```

Acabas de crear datos simulados de movimientos de animales con unas detecciones que representan errores de deteccion, pero por el momento estos datos se encuentran en diferentes vectores separados y les faltan metadatos muy importantes. Por ejemplo, metadatos utiles que nos faltan incluyen informacion sobre la replica experimental, la fecha, y para los datos de RFID, el codigo alfanumerico unico de cada etiqueta PIT que fue detectada por la antena de RFID. Algunos de estos metadatos son criticos para los analisis mas adelante, como la fecha y los codigos de las etiquetas PIT.

Los vectores son estructras utiles en R, pero una limitacion de los vectore es que no puedes combinar diferentes tipos de datos en un solo objeto. Puedes intentar combinar diferentes tipos de datos en un vector:
```{r}

# Crea un vector con los tipos `character`, `numeric`, y `binary` (o sea, datos de texto, valores numericos, y valores binarios)
# El resultado se deberia de imprimir directamente a la consola porque no estas guardando el resultado en un objeto
# Deberias de ver que todos los elementos se forzan a tipo `character` o `string` entrecomillas
c("1", 1, TRUE, FALSE)

# Ahora crea un vector con datos `numeric` y `binary`
# Deberias de poder ver que todos los elementos se forzan al tipo `numeric`. Los valores de TRUE y FALSE se conviertieron a los valores numericos que R usa por defecto para guardar informacion binaria (TRUE se convierte a 1, y FALSE se convierte a 0)
c(1, 1, TRUE, FALSE)

```

Cuando intentas combinar los tipos de dato `character`, `numeric`, y `binary` en el mismo vector, todos los elementos del vector se convierten al tipo de data `character`. Algo parecido resulta cuando intentas combinar datos de tipo `numeric` y `binary` en el mismo vector, pero en este caso, los valores se convierten a numerico. En este ejemplo, tambien aprendiste que los valores binarios TRUE y FALSE en R son equivalentes a los valores numericos 1 y 0, respectivamente.

<h2>Crear vectores de metadatos</h2>

Para los analsis que siguen, necesitas poder crear metadatos con diferentes tipos de datos, y luego combinar los datos primarios para cada sensor (las marcas de tiempo por sensor) con los metadatos importantes. Puedes empezar con crear vectores de metadatos para las marcas de tiempo de RFID, incluyendo informacion sobre la replica experimental, la fecha, y la identidad de la etiqueta PIT para cada deteccion.

Para crear un vector de metadatos sobre la replica experimental, vas a usar la funcion `rep()` para repetir la informacion sobre la replica experimental automaticamente, en vez de copiar y pegar las misma informacion varias veces. Para configurar el numero de veces que la informacion sobre la replica experimental se vaya a repetir, tambien vas a usar la funcion `length()` para calcular lo largo del vector `rfid_ts` automaticamente, y comunicarle este resultado a `rep()`. Crear un vector de metadatos que tiene el mismo largo que el vector de `rfid_ts` sera util para combinar estos vectores en un solo objeto mas adelante.
```{r}

# La documentacion nos dice que rep() espera dos argumentos, `x` y `time`
?rep

# Crea un vector con informacion sobre la replica experimental
# El argumento `x` contiene la informacion de metadatos que se va a repetir
# El argumento `times` especifica la cantidad de veces que esta informacion se va a repetir
exp_rep <- rep(x = "Pair_01", times = length(rfid_ts))

glimpse(exp_rep)

# Tambien puedes ejecutar codigo sin escribir los nombres de los argumentos, siempre y cuando los argumentos se escriben en el mismo orden que la funcion espera:
exp_rep <- rep("Pair_01", length(rfid_ts))

glimpse(exp_rep)

```

Usar `times = length(rfid_ts)` es mejor costumbre que configur lo largo de `rfid_ts` mmanualmente (por ejemplo, `times = 14`). Configurar el valor de `times` manualmente es suponer que el objeto `rfid_ts` no ha cambiado dentro de una sesion de escribir codigo, o entre sesiones diferentes, y esto puede ser una suposicion peligrosa. Cuando usas `times = length(rfid_ts)` te aseguras que el codigo arriba va a crear un vector de metadatos del mismo largo que `rfid_ts` sin importar que tantas modificaciones le hayas hecho a `rfid_ts` en el codigo arriba.

Puedes tambien usar una frase condicional para confirmar que el vector de metadatos es del mismo largo que el vector de marcas de tiempo de RFID. Las frases condicionales puede ser utiles para revisar suposiciones en tu codigo, o para construir nuevos datos y funciones.
```{r}

# Si esta condicion se cumple, el resultado en la consola deberia de ser "[1] TRUE"
length(rfid_ts) == length(exp_rep)

```

En la frase condicional arriba, estas usando los simbolos `==` para preguntar si los dos vectores `rfid_ts` y `exp_rep` tienen la misma cantidad de elementos (si tienen el mismo largo).

Tambien puedes usar los simbolos `!=` para preguntar si los dos vectores `rfid_ts` y `exp_rep` *no* tienen la misma cantidad de elementos (si *no* tienen el mismo largo):
```{r}

# El resultado de esta frase deberia de ser FALSE, porque estos vectores tienen el mismo largo
length(rfid_ts) != length(exp_rep)

```

Como un ejemplo, puedes modificar `rfid_ts` para que tenga un numero de elementos diferente a `exp_rep`. Abajo puedes ver algunas formas diferentes de filtrar o eliminra cuatro elementos del vector `rfid_ts` para que tenga diez elementos total.
```{r}

## Crear indices numericos para filtrar un objeto

# Puedes usar el simbolo `:` para crear una secuencia de numeros de los indices 5 a lo largo de rfid_ts 
5:length(rfid_ts)

# Tambien puedes usar la funcion `seq()` para crear la misma secuencia de indices numericos que ves arriba
seq(from = 5, to = length(rfid_ts), by = 1)

# Si quieres filtrar elementos no consecutivos, puedes crear un vector de indices con la funcion `c()`
c(1, 3, 5, 6, 8, 10, 11, 12, 13, 14)

## Filtrar un vector por indices numericos

# Cuando insertas cualquiera de las expresiones arriba adentro de los corchetes que vienen despues del nombre del vector, puedes seleccionar los elementos de indice cinco a lo largo de rfid_ts, y eliminar los primeros cuatro elementos 
rfid_ts[5:length(rfid_ts)]

rfid_ts[seq(from = 5, to = length(rfid_ts), by = 1)]

rfid_ts[c(1, 3, 5, 6, 8, 10, 11, 12, 13, 14)]

# Puedes usar cualquier de los metodos arriba para crear una secuencia de indices que quieres eliminar, y luego usar el simbolo `-` adentro de los corchetes para eliminar los elementos en esos indices particulares. Por ejemplo:
rfid_ts[-c(1:4)] # los numeros deberian de estar adentro de la funcion `c()` para que este tipo de filtrar de forma invertida funcione

```

Luego puedes revisar si esta version modificada de `rfid_ts` es el mismo largo que `exp_rep`:
```{r}

# Esta frase deberia de resultar en TRUE, porque estos vectores ya no tienen el mismo largo
length(rfid_ts[-c(1:4)]) != length(exp_rep)

```

<h2>Crear `dataframes` con datos primarios y metadatos</h2>

Es importante combinar los metadatos con los datos primarios para analisis futuros, y puedes combinarlos usando un tipo de objeto que se llama un `dataframe`. Los `dataframes` son parecidos a las hojas de calculo porque tienen dos dimensiones (filas y columnas), y puedes guardar multiples tipos de datos diferentes en el mismo `dataframe`. Tambien puedes guardar `dataframes` en hojas de calculo o archivos fisicos en tu computadora.

Para combinar dos vectores en un solo `dataframe`, los vectores tienen que tener el mismo largo. Cuando intentas combinar dos vectores de largo diferentes, deberias de recibir un mensaje de error en la consola especificando que los dos argumentos no tienen el mismo numero de filas:
```{r eval = FALSE}

sim_dats <- data.frame(exp_rep, rfid_ts[-c(1:4)])

# "Error in data.frame(exp_rep, rfid_ts[-c(1:4)]) : 
  # arguments imply differing number of rows: 14, 10"

```

Ahora puedes usar los vectores enteros de `exp_rep` y `rfid_ts` para crear el `dataframe`, y los vectores se van a convertir en las columnas del `dataframe`:
```{r}

sim_dats <- data.frame(exp_rep, rfid_ts)

glimpse(sim_dats)

```

Cuando revisas la estructura del objeto `sim_dats`, el `dataframe` nuevo, puedes ver que tiene 14 filas y 2 columnas. Para cada columna (despues del simbolo de "$"), puedes ver que el nombre de la columna (aqui `exp_rep` y `rfid_ts`), el tipo de dato en cada columna (en este momento cada column es del tipo `character`), y luego los valores de cada columna en las primeras filas del `dataframe`.

Puedes cambiar los nombres de cada columna con anadir un nombre nuevo y el simbolo `=` antes de cada vector. Abajo el vector `exp_rep` se convierte en la column `replicate` con la replica experimental y el vector `rfid_ts` se convierte en la columna `timestamps` con las marcas de tiempo.
```{r}

sim_dats <- data.frame(replicate = exp_rep, timestamps = rfid_ts)

glimpse(sim_dats)

```

Podemos anadir metadatos adicionales a este `dataframe`, como informacion sobre la fecha de coleccion de datos. Puedes primero añadir una columna para el año usando el tipo de datos `double` en R que es un tipo de dato `numeric`.
```{r}

sim_dats <- cbind(sim_dats, rep(2023, length(rfid_ts)))

glimpse(sim_dats)  

```

La columna del año tiene un nombre extraño cuando añadimos una nueva columna usando `cbind()`, y si revisas el codigo de arriba, puedes ver que el nombre de esta columna se parece mucho al codigo que escribiste adentro de `cbind()`. Puedes usar la funcion `names()` e indexar con corchetes para cambiar el nombre extraño a un nombre mejor, como "year":
```{r}

# Esta funcion devuelve un vector de los nombres de las columnas del `dataframe`
names(sim_dats)

# Usa indexar con corchetes y la funcion `ncol()` para encontrar el ultimo nombre entre los nombres de todas las columnas, porque esta ultima columna contiene la informacion sobre el año
ncol(sim_dats) # Hay 3 columnas en este `dataframe`

# Esta expresion devuelve el nombre de la ultima columna
names(sim_dats)[ncol(sim_dats)]

# Puedes sobreescribir el nombre de la ultima columna con un nombre nuevo
names(sim_dats)[ncol(sim_dats)] <- "year"

# Confirma que el nombre de la columna de año se actualizo de la forma que esperas
names(sim_dats)
glimpse(sim_dats)

```

<h2>Crear `dataframes` usando el `tidyverse`</h2>

En el codigo arriba, usaste codigo de R base para anadir una columna nueva y actualizar el nombre de esa columna. Te tomo varias lineas de codigo para completar estas operaciones. Puedes reducir la cantidad de codigo que necesitas para estos pasos si eliminas las lineas de codigo que usaste para revisar las operaciones. Pero otra forma para reducir la cantidad de codigo que escribes para esta serie de operaciones es usar la notacion y coleccion de funciones del `tidyverse`:
```{r}

# Crear el `dataframe` de nuevo con dos columnas
sim_dats <- data.frame(replicate = exp_rep, timestamps = rfid_ts)

# Usa el tidyverse para anadir el año como la tercera columna
sim_dats <- sim_dats %>% 
  dplyr::mutate(
    year = rep(2023, length(rfid_ts))
  )

glimpse(sim_dats)

```

Acabas de anadir una columna para el año con el nombre correcto en menos lineas de codigo. En la notacion del `tidyverse`, el simbolo de `%>%` significa una operacion de `pipe`, en que usas el objeto antes del simbolo de `%>%` como entrada para la operacion o funcion que sigue el simbolo de `%>%`. Arriba usaste el objeto de `sim_dats` como entrada para la funcion `mutate()`, que usaste para crear la columna `year`.

La notacion `dplyr::` antes de `mutate()` indica que la funcion `mutate()` se deberia de acceder desde el paquete que se llama `dplyr`. Incluir el nombre del paquete con dos puntos repetidos dos veces es una notacion importante para usar cuando hay multiples funciones accesibles en tu ambiente global con el mismo nombre. Por ejemplo, si usas otros paquetes aparte de `dplyr` que tambien tienen funciones que se llaman `mutate()`, y no especificas cual paquete quieres usar, puedes terminar con errores inmediatos (como cuando el codigo no se puede ejecutar). Incluso si el codigo ejecuta, usar la operacion equivocada de otra funcion de `mutate()` puede introducir errores a tus analisis mas adelante que son dificiles de identificar.

Las oparaciones de `piping` con el simbolo `%>%` (o un `pipe`) pueden simplicar el codigo que escribes porque no creas tantos objetos intermedios como cuando usas R base. Por otro lado, por esta misma razon puede tomar practica solucionar errors con operaciones de `piping` cuando estas operaciones son largas y anidadas. Una forma util para revisar resultados intermedios adentro de operaciones largas de `piping` es incluir la funcion `glimpse()` entre diferentes pasos de la operacion:
```{r}

# Crear el data frame otra vez con solo dos columnas
sim_dats <- data.frame(replicate = exp_rep, timestamps = rfid_ts)

# Usa el tidyverse para añadir el año como la tercera columna
sim_dats %>%
  glimpse() %>% # Ver la estructura de la primera version de sim_dats
  dplyr::mutate(
    # La expresion nrow(.) significa "obtener el numero de filas para el objeto actual". El objeto en este caso es sim_dats
    year = rep(2023, nrow(.))
  ) %>%
  glimpse() # Ver la estructura de la version mas reciente de sim_dats con la columna nueva de "year"

```

En el codigo arriba, tambien aprendiste una forma nueva para repetir un valor adentro de una operacion de `piping` con la notacion `.` adentro de una funcion, que significa que la operacion ejecutara con el objeto actual. En el ejemplo arriba, `.` se refiere al objeto `sim_dats` que se uso como entrada para la operacion entera de `piping`. Como el simbolo `.` esta adentro de la funcion `nrow()`, la funcion deberia de devolver el numero de filas de `sim_dat`.

Puedes usar una operacion parecida para anadir dos columnas al `dataframe` que contienen informacion del mes y dia:
```{r}

# Usar el tidyverse para anadir el año como la tercera columna
sim_dats %>%
  glimpse() %>% # Ver la estructura de la version original de sim_dats
  dplyr::mutate(
    year = 2023
  ) %>%
  glimpse() %>% # Ver la estructura de la version intermedia de sim_dats con la nueva columna del año
  # Tambien puedes anadir columnas para el mes ("month") y dia ("day")
  dplyr::mutate(
    month = 08,
    day = 01
  ) %>% 
  glimpse() # Ver la estructura de la version final de sim_dats con las columnas adicionales con el mes y el dia

```

En el codigo arriba, anadiste dos columnas numericas mas al `dataframe` y lo hiciste sin necesitar usar la funcion `rep()` para repetir valores. Esto fue posible porque usaste un `dataframe` que ya existia como la entrada a las operaciones de `dplyr::mutate()`, y el unico valor que especificaste para cada columna nueva del año, mes, y dia se repitio automaticamente para llenar todas las filas en el data frame para cada columna. Especificar un solo valor para una nueva columna puede ayudar reducir la cantidad de codigo que escribes, pero solo cuando de verdad quieres que el mismo valor se repite por todas las filas del `dataframe`.

Como no guardaste estas modificaciones a `sim_dats` en un objeto el resultado del codigo arriba se va a imprimir a la consola. En el siguiente tutorial, vas a guardar este `dataframe` de datos simulados de RFID y sensores infrarrojo a hojas de calculo como archivos fisicos en tu computadora.