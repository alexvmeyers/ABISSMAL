---
title: "Tutorial 03: Simular Datos"
author: "Grace Smith-Vidaurre"
date: "2023-12-27"
output: 
  html_document:
    css: "styles.css"
    toc: true
    toc_float: true
    toc_depth: 4
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

<h2>Información sobre esta traducción</h2>

Este tutorial fue traducido al español por Grace Smith-Vidaurre, siguiendo las [convenciones de traducción de los Carpentries](https://github.com/Carpentries-ES/board/blob/master/Convenciones_Traduccion.md), incluyendo usar el género femenino por defecto. Si encuentras errores de ortografía que impiden tu habilidad de completar los tutoriales, por favor reporta los errores de ortografía a GitHub usando los pasos arriba para reportar un "Issue".

<h2>Resumen del tutorial y objetivos de aprendizaje</h2>

En este tercer tutorial, vamos a crear datos simulados de moviemientos de animals que fueron detectados por diferentes sensores. El proceso de simular estos datos reemplaza el proceso de coleccion de datos que provee ABISSMAL para grabar datos de animales en vivo. Generar estos datos simulados te va a proveer mas oportunidades para practicar habilidades basicas de escribir codigo y tener control sobre la creacion de estos datos te ayudara entender los pasos diferentes de analisis de datos que siguen. Si quieres ver datos recolectados de pajaros con el software de ABISSMAL, y el codigo que fue usado para analizar esos datos, puedes revisar el preprint del [manuscrito de metodos](https://ecoevorxiv.org/repository/view/6268/) que tiene enlaces a los datos y el codigo que son publicamente acesibles.

A traves del proceso de simular datos en este tutorial, vas a continuar usando habilidades de programacion que aprendiste en el segundo tutorial, y vas a aprender habilidades adicionales que incluyen:

1. Crear objetos como vectores y `dataframes`
2. Tipos de datos en R
3. Indexar y manipular objetos
4. Usar frases condicionales
5. Expresiones de `pipe` en el `tidyverse`

<h2>Cargar paquetes</h2>

En el tutorial anterior instalaste el `tidyverse`, una coleccion de paquetes para la ciencia de datos. Tambien aprendiste sobre directorios de trabajo y creaste un directorio nuevo en tu computadora para guardar archivos de datos o imagenes que vas a generar en los siguientes tutoriales.

Cada vez que inicies un archivo nuevo de RMarkdown o R, es importante configurar tu espacio virtual antes de empezar a analizar datos. En el trozo abajo, vas a limpiar tu ambiente global y cargar el `tidyverse` usando codigo que viste en el segundo tutorial, pero ahora todo el codigo esta combinado en un solo trozo.
```{r message = FALSE, warning = FALSE}

rm(list = ls()) # Limpia tu ambiente global

library(tidyverse) # Carga la coleccion de paquetes en el tidyverse

```

<h2>Crear un objeto de `path`</h2>

El siguiente paso sera especificar tu directorio de trabajo. En el segundo tutorial, usaste un `string`, o una secuencia de caracteres entrecomillas para indicar texto adentro de codigo de R, para especificar el `path` de tu directorio de trabajo mientras usabas funciones diferentes. En vez de copiar y pegar la misma secuencia de caracteres cada vez que quieres usar este `path`, es mas eficiente guardar esta secuencia de caracteres (que especifica el `path` de tu directorio de trabajo) adentro de un objeto nuevo, y luego usar el nombre del objeto cuando necesitas especificar el `path`.

Para crear un objeto de tu `path`, puedes escribir el nombre del objeto que quieres crear al lado izquierdo del trozo (sin comillas), luego los simbolos para crear un objeto en R (`<-`), y luego la informacion que quieres asignar a este objeto. En este case, la informacion que quieres guardar adentro de este objeto es tu directorio de trabajo en el formato de un `string`, y esta informacion necesita estar entrecomillas.
```{r eval = TRUE}

path <- "/home/gsvidaurre/Desktop/ABISSMAL_tutoriales"

```

En el codigo arriba, creaste un objeto que se llama `path`. Puedes ver la informacion que contiene este objeto con escribir el nombre del objeto y ejecutar ese codigo en la consola:
```{r eval = TRUE}

path

```

Tambien puedes ver el contenido de `path` con hacer clic en la pestana de "Environment" y revisar la columna al lado derecho del nombre del objeto. Ahora puedes confirmar que `path` es un objeto nuevo que contiene informacion sobre tu directorio de trabajo y esta disponible en tu ambiente global para mas operaciones.

Puedes practicar eliminar solamente el objeto `path` de tu ambiente global con escribir y ejecutar el codigo `rm(list = "path")`. Despues de ejecutar este codigo, deberias de inicializar `path` otra vez usando el codigo arriba.

<h2>Crear marcas de tiempo para detecciones simuladas de movimientos</h2>

Los datos primarios que colecta ABISSMAL son marcas de tiempo que indican el momento en el tiempo cuando un sensor se activo y grabo movimiento. Muchas (pero no todas) de estas detecciones se pueden asignar a uno o mas animales que se movieron cerca de un sensor, por ejemplo, cuando un pajaro entra a un contenedor de nido a traves de una antena circular de RFID ("radio frequency identification") montado en la entrada del contenedor. En los siguientes trozos de codigo, vamos a generar datos simulados que representan datos de detecciones grabados por el sensor de RFID y tambien sensores de infrarrojo.

Digamos que estamos recolectando datos para 2 pajaros adultos a traves de sensores de ABISSMAL montados en un contenedor de nido. La antena de RFID esta montada en la entrada del contenedor, y un par de sensores de infrarrojo, el par "externo", esta montado en frente de la antena de RFID para capturar movimientos afuera de la entrada del contenedor. Un segundo par de sensores de infrarrojo, el par "interno", esta montado detras de la antena de RFID para capturar movimientos adentro de la entrada del contenedor. En este ejemplo simulado, el par externo de sensores infrarrojo va a activar cuando un pajaro entra al contenedor de nido, luego la antena de RFID, y luego el par interno de sensores infrarrojos. Cuando un pajaro sale del contenedor, el par interno de sensores infrarrojos deberia de activar primero, luego la antena de RFID, y luego el par externo de sensores infrarrojos.

Empezaremos con crear un objeto que contiene las marcas de tiempo simuladas para la antena de RFID. Este objecto se llamara `rfid_ts` y va a contener cuatro marcas de tiempo en formato de horas:minutos:segundos. Cada marca de tiempo estara entrecomillas para indicar que estamos usando informacion de text o secuencia de caracteres en el formato `string` de R.

Vas a combinar estas marcas de tiempo adentro de un solo objeto usando la funcion `c()`. Esta function concatena valores separados por comas en un objecto de tipo vector o lista. Arriba creaste un objeto que se llama `path` sin usar `c()`, pero este objeto tenia un solo valor o elemento. Usar `c()` facilita combinar multiple valores en un objeto como un vector que puede tener multiple elementos.
```{r}

# Crea un vector de cuatro marcas de tiempo de RFID o cuatro elementos in formato HH:MM:SS
rfid_ts <- c("10:00:00", "10:05:00", "11:00:00", "11:05:00")
  
```

Puedes ver las propiedades diferentes del objeto `rfid_ts`:
```{r}

rfid_ts # Ejecuta el nombre del objeto para ver sus contenidos

is.vector(rfid_ts) # Un valor binario indica si rfid_ts es un vector (TRUE) o no (FALSE)

class(rfid_ts) # Un vector de tipo de dato `character` en R, o tipo `string`

length(rfid_ts) # Este vector tiene cuatro elementos

```

Continuemos por simular dos movimientos de entrada y dos movimientos de salida del contenedor. Podemos escoger marcas de tiempo para el par externo de sensores de infrarrojo que preceden las marcas de tiempo de RFID y marcas de tiempo del par interno de sensores infrarrojo que siguen las marcas de tiempo de RFID para simular un evento de entrada. Podemos simular eventos de salida con las marcas de tiempo en el orden opuesto (el par interno de sensores se activa primero, luego RFID, luego el par externo de sensores de infrarrojo). Vamos a separar las detecciones de cada sensor adentro de cada movimiento de entrada y salida por un segundo.
```{r}

# Simula marcas de tiempo para el par externo ("o_") e interno ("i_") de sensores infrarrojo para una entrada, una salida, y luego otra entrada y salida
o_irbb_ts <- c("09:59:59", "10:05:01", "10:59:59", "11:05:01") # externo
i_irbb_ts <- c("10:00:01", "10:04:59", "11:00:01", "11:04:59") # interno

```

Los pajaros a veces posan en la entrada del contenedor usando la antena de RFID como percha, y los sensores deberian de colectar datos sobre este comportamiento. Puedes anadir eventos de posar a los datos simulados, y aqui vas a simular eventos de posar solamente con los datos de RFID.
```{r}

rfid_ts <- c(rfid_ts, "08:00:00", "08:00:01", "08:00:02", "08:00:03", "11:30:00", "11:30:01", "11:30:02", "11:30:03", "11:30:04", "11:30:05")

```

En el codigo arriba, modificaste el objeto `rfid_ts` con la funcion `c()` para anadir diez mas marcas de tiempo a este vector para tener un total de 14 elementos. Revisa la estructura del objeto modificado de `rfid_ts` usando la funcion `glimpse()`:
```{r}

# Aqui puedes ver la estructura del objeto en un formato que incluye el tipo de dato en R ("chr", que es tipo `character` o `string`), el numero de elementos ([1:14]), y los valores de los primeros elementos del vector
glimpse(rfid_ts)

```

Otro tipo de informacion importante es simular ruido en las detecciones de los sensores. Por ejemplo, la antena de RFID puede fallar en detectar la etiqueta PIT ("passive integrated transponder") de un individuo, y los sensores de infrarrojo pueden activarse cuando los pajaros dejan materal de nido colgando en la entrada del contenedor. En ambos casos, los sensores infrarrojos deberian de activar pero no la antena de RFID.
```{r}

# Simula unas fallas de deteccion de la antena de RFID a traves de ambos pares de sensore infrarrojos
# Estas fallas en deteccion del sensor de RFID surgio en cuatro eventos simulados adicionales (dos entradas y dos salidas)
o_irbb_ts <- c(o_irbb_ts, "06:05:05", "06:35:08", "07:15:40", "11:10:25")
i_irbb_ts <- c(i_irbb_ts, "06:05:04", "06:35:09", "07:15:41", "11:10:24")

glimpse(o_irbb_ts)
glimpse(i_irbb_ts)

# Luego simula unas detecciones de ruido para el par externo de sensores infrarrojo
o_irbb_ts <- c(o_irbb_ts, "09:45:01", "09:45:02", "09:45:03", "09:45:04", "09:45:05", "09:45:06", "09:45:07", "09:45:08", "09:45:09", "09:45:10", "09:45:11")

glimpse(o_irbb_ts)

```

Acabas de crear datos simulados de movimientos de animales con unas detecciones que representan errores de deteccion, pero por el momento estos datos se encuentran en diferentes vectores separados y les faltan metadatos muy importantes. Por ejemplo, metadatos utiles que nos faltan incluyen informacion sobre la replica experimental, la fecha, y para los datos de RFID, el codigo alfanumerico unico de cada etiqueta PIT que fue detectada por la antena de RFID. Algunos de estos metadatos son criticos para los analisis mas adelante, como la fecha y los codigos de las etiquetas PIT.

Los vectores son estructras utiles en R, pero una limitacion de los vectore es que no puedes combinar diferentes tipos de datos en un solo objeto. Puedes intentar combinar diferentes tipos de datos en un vector:
```{r}

# Crea un vector con los tipos `character`, `numeric`, y `binary` (o sea, datos de texto, valores numericos, y valores binarios)
# El resultado se deberia de imprimir directamente a la consola porque no estas guardando el resultado en un objeto
# Deberias de ver que todos los elementos se forzan a tipo `character` o `string` entrecomillas
c("1", 1, TRUE, FALSE)

# Ahora crea un vector con datos `numeric` y `binary`
# Deberias de poder ver que todos los elementos se forzan al tipo `numeric`. Los valores de TRUE y FALSE se conviertieron a los valores numericos que R usa por defecto para guardar informacion binaria (TRUE se convierte a 1, y FALSE se convierte a 0)
c(1, 1, TRUE, FALSE)

```

Cuando intentas combinar los tipos de dato `character`, `numeric`, y `binary` en el mismo vector, todos los elementos del vector se convierten al tipo de data `character`. Algo parecido resulta cuando intentas combinar datos de tipo `numeric` y `binary` en el mismo vector, pero en este caso, los valores se convierten a numerico. En este ejemplo, tambien aprendiste que los valores binarios TRUE y FALSE en R son equivalentes a los valores numericos 1 y 0, respectivamente.

<h2>Crear vectores de metadatos</h2>

Para los analsis que siguen, necesitas poder crear metadatos con diferentes tipos de datos, y luego combinar los datos primarios para cada sensor (las marcas de tiempo por sensor) con los metadatos importantes. Puedes empezar con crear vectores de metadatos para las marcas de tiempo de RFID, incluyendo informacion sobre la replica experimental, la fecha, y la identidad de la etiqueta PIT para cada deteccion.

Para crear un vector de metadatos sobre la replica experimental, vas a usar la funcion `rep()` para repetir la informacion sobre la replica experimental automaticamente, en vez de copiar y pegar las misma informacion varias veces. Para configurar el numero de veces que la informacion sobre la replica experimental se vaya a repetir, tambien vas a usar la funcion `length()` para calcular lo largo del vector `rfid_ts` automaticamente, y comunicarle este resultado a `rep()`. Crear un vector de metadatos que tiene el mismo largo que el vector de `rfid_ts` sera util para combinar estos vectores en un solo objeto mas adelante.
```{r}

# La documentacion nos dice que rep() espera dos argumentos, `x` y `time`
?rep

# Crea un vector con informacion sobre la replica experimental
# El argumento `x` contiene la informacion de metadatos que se va a repetir
# El argumento `times` especifica la cantidad de veces que esta informacion se va a repetir
exp_rep <- rep(x = "Pair_01", times = length(rfid_ts))

glimpse(exp_rep)

# Tambien puedes ejecutar codigo sin escribir los nombres de los argumentos, siempre y cuando los argumentos se escriben en el mismo orden que la funcion espera:
exp_rep <- rep("Pair_01", length(rfid_ts))

glimpse(exp_rep)

```

Usar `times = length(rfid_ts)` es mejor costumbre que configur lo largo de `rfid_ts` mmanualmente (por ejemplo, `times = 14`). Configurar el valor de `times` manualmente es suponer que el objeto `rfid_ts` no ha cambiado dentro de una sesion de escribir codigo, o entre sesiones diferentes, y esto puede ser una suposicion peligrosa. Cuando usas `times = length(rfid_ts)` te aseguras que el codigo arriba va a crear un vector de metadatos del mismo largo que `rfid_ts` sin importar que tantas modificaciones le hayas hecho a `rfid_ts` en el codigo arriba.

Puedes tambien usar una frase condicional para confirmar que el vector de metadatos es del mismo largo que el vector de marcas de tiempo de RFID. Las frases condicionales puede ser utiles para revisar suposiciones en tu codigo, o para construir nuevos datos y funciones.
```{r}

# Si esta condicion se cumple, el resultado en la consola deberia de ser "[1] TRUE"
length(rfid_ts) == length(exp_rep)

```

En la frase condicional arriba, estas usando los simbolos `==` para preguntar si los dos vectores `rfid_ts` y `exp_rep` tienen la misma cantidad de elementos (si tienen el mismo largo).

Tambien puedes usar los simbolos `!=` para preguntar si los dos vectores `rfid_ts` y `exp_rep` *no* tienen la misma cantidad de elementos (si *no* tienen el mismo largo):
```{r}

# El resultado de esta frase deberia de ser FALSE, porque estos vectores tienen el mismo largo
length(rfid_ts) != length(exp_rep)

```

Como un ejemplo, puedes modificar `rfid_ts` para que tenga un numero de elementos diferente a `exp_rep`. Abajo puedes ver algunas formas diferentes de filtrar o eliminra cuatro elementos del vector `rfid_ts` para que tenga diez elementos total.
```{r}

## Crear indices numericos para filtrar un objeto

# Puedes usar el simbolo `:` para crear una secuencia de numeros de los indices 5 a lo largo de rfid_ts 
5:length(rfid_ts)

# Tambien puedes usar la funcion `seq()` para crear la misma secuencia de indices numericos que ves arriba
seq(from = 5, to = length(rfid_ts), by = 1)

# Si quieres filtrar elementos no consecutivos, puedes crear un vector de indices con la funcion `c()`
c(1, 3, 5, 6, 8, 10, 11, 12, 13, 14)

## Filtrar un vector por indices numericos

# Cuando insertas cualquiera de las expresiones arriba adentro de los corchetes que vienen despues del nombre del vector, puedes seleccionar los elementos de indice cinco a lo largo de rfid_ts, y eliminar los primeros cuatro elementos 
rfid_ts[5:length(rfid_ts)]

rfid_ts[seq(from = 5, to = length(rfid_ts), by = 1)]

rfid_ts[c(1, 3, 5, 6, 8, 10, 11, 12, 13, 14)]

# Puedes usar cualquier de los metodos arriba para crear una secuencia de indices que quieres eliminar, y luego usar el simbolo `-` adentro de los corchetes para eliminar los elementos en esos indices particulares. Por ejemplo:
rfid_ts[-c(1:4)] # los numeros deberian de estar adentro de la funcion `c()` para que este tipo de filtrar de forma invertida funcione

```

Luego puedes revisar si esta version modificada de `rfid_ts` es el mismo largo que `exp_rep`:
```{r}

# Esta frase deberia de resultar en TRUE, porque estos vectores ya no tienen el mismo largo
length(rfid_ts[-c(1:4)]) != length(exp_rep)

```

TKTK continue translation

<h2>Create data frames with primary data and metadata</h2>

For later analyses, it is really important to have the metadata accompany your primary data in the very same object. To combine the primary data and metadata for these simulated datasets, you can rely on an object called a "data frame". Data frames are similar to spreadsheets. They have 2 dimensions (rows and columns), and you can store multiple different types of data in the same data frame. You can also write out data frames to spreadsheets that exist as physical files on your computer.

When you try making a data frame with vectors of different length, you should get an error message stating that the two arguments provided have different numbers of rows:
```{r eval = FALSE}

sim_dats <- data.frame(exp_rep, rfid_ts[-c(1:4)])

# "Error in data.frame(exp_rep, rfid_ts[-c(1:4)]) : 
  # arguments imply differing number of rows: 14, 10"

```

Now use the full `exp_rep` and `rfid_ts` vectors to create the data frame, in which these vectors become columns of the data frame:
```{r}

sim_dats <- data.frame(exp_rep, rfid_ts)

glimpse(sim_dats)

```

When you check out the structure of the new data frame `sim_dats`, you can see that it has 14 rows and 2 columns. For each column (after the "$" symbol), you can see the column name (here `exp_rep` and `rfid_ts`), the type of data in each column (both columns are type "character"), and then a preview of the first values in each column.

You can change the column names by adding a new name and `=` before each vector. Here the vector `exp_rep` becomes the column `replicate` and the vector `rfid_ts` becomes the column `timestamps``
```{r}

sim_dats <- data.frame(replicate = exp_rep, timestamps = rfid_ts)

glimpse(sim_dats)

```

We can add additional metadata to this data frame now that it's been created. For instance, it would be useful to have information about the date when these timestamps were collected. You can start by adding a column for the year, which will be data type "dbl" (which stands for "double" or "numeric"):
```{r}

sim_dats <- cbind(sim_dats, rep(2023, length(rfid_ts)))

glimpse(sim_dats)  

```

The year column has a strange name when we add the new column using `cbind()`. The column name is the expression that you wrote inside of `cbind()`. You can use the function `names()` and square bracket indexing to change the strange column name to "year":
```{r}

# This function returns a vector of the column names of the data frame 
names(sim_dats)

# Use square bracket indexing and the function `ncol()` to find the last column name
ncol(sim_dats) # There are 3 columns in this data frame

# This expression gets you the name of the last column
names(sim_dats)[ncol(sim_dats)]

# Then you can overwrite the last column name with a new name
names(sim_dats)[ncol(sim_dats)] <- "year"

# Confirm that the name was changed correctly
names(sim_dats)
glimpse(sim_dats)

```

<h2>Create data frames using the tidyverse</h2>

In the chunk above, you used base R code to add a new column and to update the column name. It took more than a few lines of code to carry out these operations. You could reduce the amount of code needed for these steps by removing the lines included to check your work. But another way that you can reduce the amount of code you're writing for these operations is to use tidyverse notation and functions:
```{r}

# Make the data frame again with only 2 columns
sim_dats <- data.frame(replicate = exp_rep, timestamps = rfid_ts)

# Use the tidyverse to add the year as the 3rd column
sim_dats <- sim_dats %>% 
  dplyr::mutate(
    year = rep(2023, length(rfid_ts))
  )

glimpse(sim_dats)

```

You added a column for the year with the correct column name in fewer lines of code. In this tidyverse syntax, the symbol `%>%` represents a piping operation, in which you're using one object as the input for a subsequent operation. Here, you're using the object `sim_dats` at the input for the function `mutate()`, which you used to create the column `year`. 

The notation `dplyr::` before `mutate()` indicates that the function `mutate()` should be sourced from the package called `dplyr()`. Including the package name with 2 colons before a function name is important when there are multiple functions loaded in your global environment that have the same name. For instance, if you use other packages that also have functions called `mutate()`, and you don't specify which package you want to use, then you could end up with immediate errors (the code fails to run) or worse, you could run the wrong `mutate()` operation for a given analysis (which can lead to errors down the line that are harder to trace).

Piping operations can simplify the code that you write, so that you don't have to create as many intermediate objects. On the other hand, for the same reason it can take practice to troubleshoot piping operations, especially when they become very long. A useful way to check intermediate results within long piping operations is to include the function `glimpse()` between different piping steps:
```{r}

# Make the data frame again with only 2 columns
sim_dats <- data.frame(replicate = exp_rep, timestamps = rfid_ts)

# Use the tidyverse to add the year as the 3rd column
sim_dats %>%
  glimpse() %>% # See the structure of the first version sim_dats
  dplyr::mutate(
    # The nrow(.) expression means "get the number of rows for the current object", which in this case is sim_dats
    year = rep(2023, nrow(.))
  ) %>%
  glimpse() # See the structure of the latest sim_dats with the new column "year"

```

In the code above, you also learned a new way to repeat a value within a piping operation by using the notation '.' inside of a function, which means that you will perform the given operation (getting the number of rows) on the current object (`sim_dats`) piped into the expression (the `nrow()` function). 

You can use a similar rule of thumb to add two more columns for the month and day to the data frame:
```{r}
 
# Use the tidyverse to add the year as the 3rd column
sim_dats %>%
  glimpse() %>% # See the structure of the original sim_dats
  dplyr::mutate(
    year = 2023
  ) %>%
  glimpse() %>% # See the structure of the intermediate sim_dats with the new column year
  # Also add columns for the month and day
  dplyr::mutate(
    month = 08,
    day = 01
  ) %>% 
  glimpse() # See the structure of the final sim_dats with the additional new columns month and day

```

In the code above, you added 2 more numeric columns to the data frame and you did this without needing to use the `rep()` function. Since you piped an existing data frame into each `dplyr::mutate()` expression, the single value that you specified for each of the year, month, and day columns was automatically repeated to fill the total rows in the data frame. Specifying a single value for a new column can help reduce the amount of code that you write, but only when you truly want the same value repeated across all rows of a data frame.

You did not save these modifications that you made to `sim_dats` in an object, so the output was printed to the console only. In the next vignette, you will write out this data frame of simulated RFID and IRBB data to spreadsheets as physical files on your computer.