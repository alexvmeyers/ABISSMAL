---
title: "Tutorial 04: Guardar Datos"
author: "Grace Smith-Vidaurre"
date: "2023-12-27"
output: 
  html_document:
    css: "styles.css"
    toc: true
    toc_float: true
    toc_depth: 4
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

<h2>Información sobre esta traducción</h2>

Este tutorial fue traducido al español por Grace Smith-Vidaurre, siguiendo las [convenciones de traducción de los Carpentries](https://github.com/Carpentries-ES/board/blob/master/Convenciones_Traduccion.md), incluyendo usar el género femenino por defecto. Si encuentras errores de ortografía que impiden tu habilidad de completar los tutoriales, por favor reporta los errores de ortografía a GitHub usando los pasos arriba para reportar un "Issue".

<h2>Resumen del tutorial y objetivos de aprendizaje</h2>

En este cuarto tutorial, vas a guardar hojas de calculo de las detecciones simuladas de movimientos de animales a tu computadora. Vas a continuar usando habilidades que aprendiste en los tutoriales anteriores, y vas a aprender nuevas habilidades que incluyen:

1. Indexar y filtrar `dataframes`
2. Revisar la estructura de `dataframes` con R base y el `tidyverse`
3. Guardar objetos de R como archivos fisicos en tu computadora
4. Leer archivos de tu computadora a R
5. Escribir y probar bucles

<h2>Cargar paquetes e inicializar el `path` de tu directorio de trabajo</h2>

```{r message = FALSE, warning = FALSE}

rm(list = ls()) # Limpiar tu ambiente global

library(tidyverse) # Cargar la coleccion de paquetes del tidyverse

path <- "/home/gsvidaurre/Desktop/ABISSMAL_vignettes" # Inicializar un objeto con el path de tu directorio de trabajo

```

<h3>Crear los datos simulados</h3>

En el codigo abajo, vas a recrear los datos simulados de RFID y sensores infrarrojos del tutorial anterior. Aqui estamos combinando el codigo en menos trozos comparado con el tercer tutorial:
```{r}

# Crea un vector de cuatro marcas de tiempo de RFID en formato HH:MM:SS
rfid_ts <- c("10:00:00", "10:05:00", "11:00:00", "11:05:00")

# Anade eventos de posar a los datos de RFID
rfid_ts <- c(rfid_ts, "08:00:00", "08:00:01", "08:00:02", "08:00:03", "11:30:00", "11:30:01", "11:30:02", "11:30:03", "11:30:04", "11:30:05")

glimpse(rfid_ts)

```

```{r}

# Simula marcas de tiempo para los pares externos ("o_") e internos ("i_") de sensores infrarrojos para una entrada y una salida, y luego otra entrada y salida
o_irbb_ts <- c("09:59:59", "10:05:01", "10:59:59", "11:05:01")
i_irbb_ts <- c("10:00:01", "10:04:59", "11:00:01", "11:04:59")

# Simula unos errores de deteccion por la antena de RFID en las marcas de tiempo de cada par de sensores infrarrojos
# Estos errores de deteccion surgieron en cuatro movimientos adicionales: dos entradas y dos salidas
o_irbb_ts <- c(o_irbb_ts, "06:05:05", "06:35:08", "07:15:40", "11:10:25")
i_irbb_ts <- c(i_irbb_ts, "06:05:04", "06:35:09", "07:15:41", "11:10:24")

# Simula unas detecciones de ruido en las marcas de tiempo del par externo de sensores infrarrojo
o_irbb_ts <- c(o_irbb_ts, "09:45:01", "09:45:02", "09:45:03", "09:45:04", "09:45:05", "09:45:06", "09:45:07", "09:45:08", "09:45:09", "09:45:10", "09:45:11")

glimpse(o_irbb_ts)
glimpse(i_irbb_ts)

```

<h3>Simula tres dias de coleccion de datos de RFID</h3>

En el codigo abajo, vas a combinr el vector de marcas de tiempo de RFID que inicializaste arriba con metadatos en un `dataframe`. Estos metadatos van a incluir el año, el mes, y el dia, y tambien una columna con los valores de dos etiquetas PIT (una etiqueta por individuo simulado), y una columna con informacion sobre el tipo de sensor. Deberias de reconocer partes de este codigo desde el tutorial anterior:
```{r}

# Crea un vector para la replica experimental
exp_rep <- rep(x = "Nest_01", times = length(rfid_ts))

# Crea un vector de las identidades de las etiquetas PIT
# Asigna las primeras cuatro detecciones de RFID al primer individuo, el primer evento de posar (4 detecciones) al primer individuo, y el segundo evento de posar (6 detecciones) al segundo individuo
# Estas tres expresiones de rep() estan combinadas en un solo vector usando la funcion c()
PIT_tag <- c(rep("1357aabbcc", 4), rep("1357aabbcc", 4), rep("2468zzyyxx", 6))

# Crea el dataframe con los metadatos de replica experimental y las marcas de tiempo
sim_dats_rfid <- data.frame(chamber_id = exp_rep, timestamps = rfid_ts)

# Sobrescribe el datafram con la version modificada que tiene columnas para el año, el mes, y el dia
sim_dats_rfid <- sim_dats_rfid %>%
  dplyr::mutate(
    year = 2023
  ) %>%
  dplyr::mutate(
    month = 08,
    day = 01
  ) %>%
  # Anade los metadatos de las etiquetas PIT en una columna nueva
  dplyr::mutate(
    PIT_tag = PIT_tag
  ) %>% 
  dplyr::mutate(
    sensor_id = "RFID"
  )

glimpse(sim_dats_rfid)

```

Ahora puedes usar este `dataframe` para simular el proceso de coleccion de datos a traves de dos dias mas. Para crear mas observaciones (filas) para dos dias adicionales, puedes adjuntar filas de una copia modificada de `sim_dats_rfid` al objeto original de `sim_dats_rfid`.

En el codigo abaho, estas usando una operacion `pipe` para usar `sim_dats_rfid` como entrada en `bind_rows()`, y con esta notacion estas especificando que `sim_dats_rfid` es el objeto original al cual quieres adjuntar mas filas. Luego el codigo adentro de `bind_rows()` especifica el `dataframe`, o las filas nuevas, que quieres adjuntar a `sim_dats_rfid`. En este case, el codigo adentro de `bind_rows()` provee `sim_dats_rfid` a `dplyr::mutate()` para modificar la columna de `day` para representar un dia adicional de coleccion de datos. Luego repites este proceso para anadir un tercer dias de recolectar datos:
```{r}

sim_dats_rfid <- sim_dats_rfid %>% 
  bind_rows(
    sim_dats_rfid %>% 
      dplyr::mutate(
        day = 02
      )
  ) %>% 
  bind_rows(
    sim_dats_rfid %>% 
      dplyr::mutate(
        day = 03
      )
  )

glimpse(sim_dats_rfid) # Tres veces el numero original de filas, se ve bien

```

<h3>Revisar columnas de `dataframe` con R base</h3>

Acabas de revisar la estructura del `dataframe` para confirmar que los datos simulados tiene datos recolectados a traves de tres dias. Tambien puedes revisar los valores unicos que estan presentes en la columna de `day`. Abajo puedes ver una forma de revisar los valores unicos adentro de una columna de un `dataframe`, usando dos ejemplos diferentes de notacion de R base para acceder columnas adentro de un `dataframe`:
```{r}

# Escribir una expresion con el nombre de un objeto dataframe, un simbolo $, y el nombre de una columna te ayuda sacar o acceder una columan a la vez de un dataframe. Una columna de un dataframe es un vector, por ende cuando ejecutas este codigo deberias de ver un vector de valores impreso en la consola
sim_dats_rfid$day

# Puedes tambien acceder una columna en un dataframe con indexar si escribes dos pares corchetes (ambos pares de abrir y cerrar) despues del nombre del dataframe, y colocas el nombre de la columna entrecomillas adentro de del par interno de corchetes
sim_dats_rfid[["day"]]

# Puedes usar la funcion unique() para ver los valores unicos adentro de un vector, incluyendo una columna en un dataframe
unique(sim_dats_rfid$day) # Tres dias, se ve bien

unique(sim_dats_rfid[["day"]]) # Tres dias, se ve bien

```

<h3>Revisar columnas de un `dataframe` con el `tidyverse`</h3>

Tambien puedes revisar valores unicos en una columna usando funciones del `tidyverse`. En la expresion abajo, vas a usar una expresion de `pipe` para proveer el `dataframe` `sim_dats_rfid` a la funcion `pull()`, que va a facilitar acceder la columna `day` del dataframe como un vector. Luedo este vector de la columna `day` se va a usar como entrada a la funcion `unique()` para revisar los valores unicos del vector mismo. La funcion `unique()` no require un argumento adentro de los parentesis porque ya recibio el valor de entrada que necesita a traves de la operacion de `piping`.
```{r}

# Tres dias, se ve bien
sim_dats_rfid %>% 
  pull(day) %>% 
  unique()

```

<h3>Simula tres dias de recolectar datos de los sensores infrarrojo</h3>

Ahora puedes repetir este proceso de crear un `dataframe` con metadatos para los datos de los sensores de infrarrojo. Dado que los sensores de infrarrojo no colectan informacion sobre la identidad unica de individuos, vas a anadir columnas para el año, el mes, el dia, y el tipo de sensor. Tambien vas a simular la coleccion de datos para estos sensores a traves de los mismos tres dias que los datos simulados de RFID.
```{r}

# Sobreescribe el vector exp_rep con un vector nuevo que tiene el mismo largo que los vectores o_irbb_ts y i_irbb_ts juntos
exp_rep <- rep(x = "Nest_01", times = length(o_irbb_ts) + length(i_irbb_ts))

# Anade las marcas de tiempo de ambos pares de sensores infrarrojo a la misma columna usando c()
sim_dats_irbb <- data.frame(chamber_id = exp_rep, timestamps = c(o_irbb_ts, i_irbb_ts))

sim_dats_irbb <- sim_dats_irbb %>%
  dplyr::mutate(
    year = 2023,
    month = 08,
    day = 01,
    # Anade un identificador unico para cada par de sensores
    # Cada etiqueta unica se repitira por lo largo del vector de marcas de tiempo de cada par de sensores infrarrojo
    sensor_id = c(rep("Outer Beam Breakers", length(o_irbb_ts)), rep("Inner Beam Breakers", length(i_irbb_ts)))
  )

glimpse(sim_dats_irbb)

sim_dats_irbb <- sim_dats_irbb %>% 
  bind_rows(
    sim_dats_irbb %>% 
      dplyr::mutate(
        day = 02
      )
  ) %>% 
  bind_rows(
    sim_dats_irbb %>% 
      dplyr::mutate(
        day = 03
      )
  )

glimpse(sim_dats_irbb) # Tres veces el numero de filas, se ve bien

# Tres dias, se ve bien
sim_dats_irbb %>% 
  pull(day) %>% 
  unique()

```

<h2>Guarda un `dataframe` como un archivo fisico</h2>

Los `dataframes` que creas y manipulas en R se pueden guardar como archivos fisicos en tu directorio de trabajo. Tienes muchas opciones diferentes para guardar `dataframes`, pero recomiendo que uses formato `.csv` porque este formato es compatible con R, Microsoft Word, y otros programas. Puedes usar la funcion `write.csv()` para guardar `dataframes` a hojas de calculo `.csv` en tu computadora:
```{r eval = FALSE}

?write.csv

```

Para escribir un archivo fisico a tu directorio de trabajo, necesitas comunicarle a R 1) donde guardar el archivo y 2) el nombre del archivo que quieres crear. Puedes pasarle ambas piezas de informacion a `write.csv()` con combinar tu directorio de trabajo y el nombre del archivo usando la funcion `file.path()`. Para este ejemplo, vas a crear un archivo de preuba mientras practicas como usar `write.csv()`:
```{r}

# Combina el path para tu directorio de trabajo con el nombre del archivo que quieres escribir
# La funcion file.path() combinara ambas piezas de informacion en un solo path para este archivo
rfid_file <- file.path(path, "test_file.csv")

# Este objeto contiene la ubicacion donde vas a guardar el archivo, y luego el nombre del archivo
rfid_file

```

Luego puedes proveer el `dataframe` a `write.csv()` usando un `pipe` y puedes especificar informacion adicional para crear el archivo `.csv`, como si quieres anadir una columna adicional de identidades numericas de las filas:
```{r eval = FALSE}

sim_dats_rfid %>%
  # Escribe el dataframe como una hoja de calculo en formato .csv. No incluyes los nombres de las filas (row.names = FALSE)
  # El simbolo "." abajo significa que la funcion write.csv() va a operar sobre el objeto que proveyo el pipe, que en este caso es el objeto sim_dats_rfid
  write.csv(x = ., file = rfid_file, row.names = FALSE)

```

Como se especifica en la documentacion para la funcion `write.csv()`, esta funcion va a incluir las nombres de las columnas en la hoja de calculo por defecto. La funcion tambien no va a adjuntar esta informacion en el `dataframe` al archivo de `.csv` si esta hoja de calculo ya existe, o sea, si ya creaste el archivo de `.csv` y vuelves a correr el codigo arriba, el archivo se va a sobrescribir por defecto.

Puedes revisar que `write.csv()` funcion como esperabas con usar `list.files()` para ver los archivos en tu directorio de trabajo.
```{r eval = FALSE}

# Ve una lista de todos los archivos en este path
list.files(path)

```

Tambien puedes usar `list.files()` para customizar una busqueda con el argumento `pattern`. Usar el argumento `pattern` es parecido a buscar una palabra especifica adentro de un documento de texto. El simbolo de "$" despues de ".csv" significa que la funcion deberia de buscar todos los archivos que *terminan* en el patron ".csv".
```{r eval = FALSE}

# Devuelve solo archivos que terminan en el patron ".csv" en este path particular
list.files(path, pattern = ".csv$")

```

<h3>Leer una hoja de calculo</h3>

Ahora puedes leer uno de estos archivos con R usando la funcion `read.csv()`. En el codigo abajo, vas a proveer el resultado de `read.csv()` a la funcion `glimpse()` para revisar la estructura del `dataframe` creado en R cuando leiste el archivo. El resultado de este codigo se imprime a la consola porque no esta guardado adentro de un objeto.
```{r eval = FALSE}

read.csv(file.path(path, "test_file.csv")) %>% 
  glimpse()

```

Ahora que practicaste usar `write.csv()` y `read.csv()`, puedes eliminar el archivo temporal que creaste con proveer el objeto `rfid_file` a la funcion `file.remove()`.
```{r eval = FALSE}

rfid_file <- file.path(path, "test_file.csv")
rfid_file

file.remove(rfid_file)

```

<h2>Guardar datos simuladoes para analisis con ABISSMAL</h2>

En el codigo abajo, vas a trabajar con una serie de pasos para guardar los datos simulados en el formato y en las ubicaciones esperadas por las funciones de ABISSMAL. Para poder usar estas funciones de ABISSMAL, los datos simulados originales se tienen que guardar en una hoja de calculo diferente por el tipo de sensor y el dia de coleccion de datos. Estas hojas de calculo se tienen que guardar adentro de una carpeta por tipo de sensor. ABISSMAL guarda los datos originales de esta misma forma cuando el sistema se usa para colectar datos empiricos de animales.

<h3>Filtrar un `dataframe`</h3>

Vas a practicar como usar la funcion `dplyr::filter()` para filtrar filas de un `dataframe` por dia y luego guardar un `dataframe` filtrado con `write.csv()`. Para filtrar un `dataframe`, puedes usar una frase condicional adentro de la funcion `dplyr::filter()`:
```{r}

# Provee el dataframe a la funcion filter() con un "pipe"
sim_dats_rfid %>% 
  # Filtra el dataframe con seleccionar todas las filas en que la columna de dia era igual a uno (el primer dia de coleccion de datos)
  dplyr::filter(day == 1) %>%
  glimpse()

# Revisa que este paso de filtrar se hizo correctamente. El unico valor adentro de la columna del dia deberia de ser uno, y se ve bien
sim_dats_rfid %>% 
  dplyr::filter(day == 1) %>%
  pull(day) %>% 
  unique()

```

Puedes obtener resultados similares cuando inviertes la frase condicional adentro de `dplyr::filter()` para eliminar los dias que **no** fueron ni el segundo dia ni el tercer dia de coleccion de datos. Abajo combinaste dos frases condicionales usando el simbolo de "&".
```{r}

sim_dats_rfid %>%
  # Filtra el dataframe con seleccionar todas las filas en que los valores en la columna de dia no son iguales a 2 o 3
  dplyr::filter(day != 2 & day != 3) %>%
  glimpse()

# Usa la funcion par ver los valores uncios en una columna para revisar que el proceso de filtrar se completo bien. Se ve bien
sim_dats_rfid %>% 
  dplyr::filter(day != 2 & day != 3) %>%
  pull(day) %>% 
  unique()

```

Ahora que practicaste filtrar un `dataframe`, puedes combinar este paso de filtrar con escribir un archivo `.csv` que contiene el `dataframe` filtrado por los datos colectados en un solo dia:
```{r eval = FALSE}

# Crea un directorio nuevo adentro de tu directorio de trabajo para guardar datos
file.path(path, "Data") # Revisa el path nuevo
dir.create(file.path(path, "Data")) # Crea el path nuevo

# Crea un directorio nuevo adentro del directorio de Data para los datos originales de RFID
file.path(path, "RFID") # Revisa el path nuevo
dir.create(file.path(path, "Data", "RFID")) # Crea el path nuevo

# Inicializa el nombre del archivo nuevo con el path de tu directorio de trabajo 
# Asegurate de especificar que el archivo se va a guardar adentro de la carpeta neuva "RFID"
rfid_file <- file.path(path, "Data/RFID", "test.csv")
rfid_file

# Filtra los datos simulados de RFID para sacar el primer dia de coleccion de datos
sim_dats_rfid %>% 
  dplyr::filter(day == 1) %>% 
  # Escribe el dataframe filtrado como una hoja de calculo en formato .csv. No incluyes nombres para las filas
  # Recuerda que el simbolo "." significa que la funcion ca a usar el objeto que proveyo la operacion de "pipe", que aqui es el dataframe filtrado para seleccionar solo el primer dia de coleccion de datos
  write.csv(x = ., file = rfid_file, row.names = FALSE)

```

Revisa que el archivo de prueba se creo adentro de la carpeta nueva de RFID, y luego puedes eliminar este archivo.
```{r eval = FALSE}

list.files(file.path(path, "Data/RFID"), pattern = ".csv$")

rfid_file <- file.path(path, "Data/RFID", "test.csv")
rfid_file

file.remove(rfid_file)

```

<h3>Practicar escribir un bucle</h3>

Podrias repetir el codigo arriba seis veces (tres veces por sensor) para escribir un `dataframe` por cada dia de coleccion de datos por sensor. Pero es mejor evitar repetir el mismo codigo varias veces, porque cuando escribes codigo de esta forma es mas dificil mantener archivos organizados de codigo y tambien es mas facil introducir errors mientras procesas y analizas datos. Cuando necesitas ejecutar el mismo codigo varias veces, es mejor escribir un bucle. Escribir bucles es una habilidad muy importante y vamos a construir un bucle paso por paso.

Vas a practicar como escribir un bucle con la funcion `lapply()`.
```{r}

?lapply

# Crea un vector de los archivos que quieres guardar
files <- c(file.path(path, "Data/RFID", "test1.csv"), file.path(path, "Data/RFID", "test2.csv"))

files
length(files)

```

Ahora puedes empezar a escribir la estructura de un bucle. En el codigo abajo, el argumento `X` es el numero de veces que se va a ejecutar el bucle. En este caso, `X` es un vector numerico de uno al largo del vector `files` y contiene los numeros uno y dos. Por end, el bucle va a ejecutar dos veces, y cada valor consecutivo en `X` se va a usar en cada iteracion correspondiente del bucle para escribir un archivo a la vez. 
El argumento `FUN` es una funcion customizada que fue escrita usando la notacion `function(x){}`. Todo el codigo adentro de las llaves curvas (abre y cierre) se ejecutara en cada iteracion del bucle. El argumento `x` adentro de `funcion()` es el variable de iteracion, o el variable que va a tomar un valor diferente del vector `X` en cada iteracion.
```{r}

# En este bucle el variable de iteracion x va a tomar cada valor del vector en el argumento X. Por ejemplo, en la primera iteracion del bucle, x va a tomar el valor numerico de 1. En la segunda iteracion del bucle, x va a tomra el valor numerico de 2. Para probar esta logica puedes ejecutar el bucle abajo, y ver el valor de x que va a imprimir en cada iteracion en la consola
lapply(X = 1:length(files), FUN = function(x){
  
  x
  
})

```

TKTK continue translation

As you can see, the output of this loop is a list with 2 elements. Each list element is shown in double square brackets ([[1]] and [[2]]), and each list element contains a vector of length 1 that holds the value of the iterating variable in each iteration (1 and 2, respectively). 

The iterating variable of the loop, or `x`, does not exist as an object outside of the function. So if you print `x` outside of the loop, no object will be found. If you created a object called `x` outside of the loop above, then you will see the contents of that object instead. This means that writing a loop that uses `x` as an iterating variable will not affect other lines of code that use an object called `x` outside of the loop, and vice versa.

The iterating variable of a function does not always need to be `x`, but can be another letter (`i`, `j`, `y`, `z`) or any combination of multiple letters and numbers, underscores, and periods (as long as the variable name starts with a letter).

A useful property of the iterating variable is that you can use it to index vectors, data frames, or other objects that you created outside of the loop. For instance, you can use `x` and square bracket indexing to print the name of each file that you want to save:
```{r}

lapply(X = 1:length(files), FUN = function(x){
  
  files[x]
  
})

```

You can also modify the code inside of the custom function to save each of these files, by placing the expression `files[x]` inside of the `write.csv()` function and piping a data frame to `write.csv()`.
```{r eval = FALSE}

lapply(X = 1:length(files), FUN = function(x){
  
  # In each iteration of the loop, you will save the data frame `sim_dats_rfid` as a separate spreadsheet with the file name specified in the given iteration
  sim_dats_rfid %>%
    write.csv(file = files[x], row.names = FALSE)
  
})

```

You should see 2 "NULL" outputs printed to the console if the loop runs correctly. When you check the contents of the nested RFID folder, you should see that both of the testing .csv files were written out:
```{r}

list.files(file.path(path, "Data/RFID"))

```

You just wrote out 2 spreadsheets using 1 loop, but you wrote out the same data frame to each spreadsheet. In order to write out a different data frame to each spreadsheet, you can add the data frame filtering that you learned above to the loop. In the code below, you'll also create another vector object called `days`, and then use the iterating variable to filter `sim_dats_rfid` and write out a spreadsheet by each day in `days`.
```{r eval = FALSE}

days <- c(1, 2, 3)

lapply(X = 1:length(files), FUN = function(x){
  
  sim_dats_rfid %>%
    # Filter the data frame by one day at a time
    dplyr::filter(day == days[x]) %>%
    # Write out data frame filtered by the given data to a separate spreadsheet 
    write.csv(file = files[x], row.names = FALSE)
  
})

```

You can delete these files that you created for testing. In the code below, you're seeing another pattern searching example while checking whether the function ran correctly. The string that you pass to the argument `pattern` starts with the symbol `^`, which is a symbol that indicates you're searching for all files that *start* with the pattern "test". You're also telling the function to return the full location of each file along with the file name, so that `file.remove()` knows exactly where to look for each file.
```{r eval = FALSE}

rem_files <- list.files(file.path(path, "Data/RFID"), pattern = "^test", full.names = TRUE)
rem_files

file.remove(rem_files)

```

<h3>Use a loop to save RFID spreadsheets</h3>

Now you can put all of these pieces together and use the loop to write out a spreadsheet per day for the RFID sensor.
```{r eval = FALSE}

# Make a vector of the custom file names to write out
files <- c(
  "RFID_simulated_Pair-01_2023_08_01.csv", 
  "RFID_simulated_Pair-01_2023_08_02.csv", 
  "RFID_simulated_Pair-01_2023_08_03.csv"
)

# Add the file path for the correct directory
files <- file.path(path, "Data/RFID", files) 
files

# Make a vector of the days to write out (1 day per iteration of the loop)
days <- c(1, 2, 3)
days

# You can drop the lapply() argument names, since you're supplying the arguments in the order that the function expects
invisible(lapply(1:length(files), function(x){
  
  sim_dats_rfid %>%
    # Filter the data frame by one day at a time
    dplyr::filter(day == days[x]) %>%
    # Write out the filtered data frame to the correct spreadsheet for the given day
    write.csv(file = files[x], row.names = FALSE)
  
}))

```

In the code above, you'll see one additional change that we made to the loop by wrapping it in the function `invisible()`. This function silences the output printed to the console that you saw several times above, in which the output of each `lapply()` iteration is enclosed in double square brackets, and then a single pair of square brackets. `lapply()` is a function that returns a list, and when the function is carried out correctly but there is not output to print, the function will return `NULL` values (indicating empty output). This is the expected behavior of `lapply()` for our purposes, because we used `lapply()` to write out physical files rather than to return output to the R console. Since you can check that the function worked by running `list.files()`, using `invisible()` helps clean up the amount of text that you need to check in your console.

```{r eval = FALSE}

# The new .csv files for each day of RFID data are present, looks good
list.files(file.path(path, "Data/RFID"))

```

You can remove these files for now, since you will work on writing a nested loop structure that automatically writes out the data for each sensor type per day.
```{r eval = FALSE}

files <- c("RFID_simulated_Pair-01_2023_08_01.csv", "RFID_simulated_Pair-01_2023_08_02.csv", "RFID_simulated_Pair-01_2023_08_03.csv")

# Add the file path for the correct directory
files <- file.path(path, "Data/RFID", files) 
files

file.remove(files)

```

If you want more practice writing loops, you can write out a loop structure to save a spreadsheet for each day of data collection for the infrared beam breaker dataset.

<h3>Write a nested loop to save spreadsheets</h3>

If you want to cut down on the amount of code that you're writing to save the raw data per sensor and day of data collection, you could write out both the RFID and beam breaker data in the same looping structure. To continue, you'll need to create another directory for the beam breaker data:
```{r eval = FALSE}

dir.create(file.path(path, "Data", "IRBB"))

```

To carry out the file filtering and writing for both sensor types across days, you'll use a type of object called a `list`. You will then use these lists inside of a nested loop structure:
```{r}

# Make a list of the custom file names to write out for each sensor type and day
files <- list(
  c("RFID_simulated_Pair-01_2023_08_01.csv", "RFID_simulated_Pair-01_2023_08_02.csv", "RFID_simulated_Pair-01_2023_08_03.csv"),
  c("IRBB_simulated_Pair-01_2023_08_01.csv", "IRBB_simulated_Pair-01_2023_08_02.csv", "IRBB_simulated_Pair-01_2023_08_03.csv")
)

glimpse(files)

```

Lists are useful objects because they're very flexible. Unlike vectors, a single list can hold many different types of data. And then unlike a data frame, the elements of a list do not need to have the same dimensions. The elements of a list can also be different data structures or object types themselves. For instance, lists can contain vectors, data frames, and other lists all inside of the same larger list object. For instance, the list that you created above has 2 elements, and each element is a vector of 3 character strings containing the file names that you supplied using the function `c()`.

You can index lists in a manner that is similar to indexing vectors and data frames, but indexing lists can be done with single or double square brackets for different outcomes:
```{r}

# Using a single square bracket to filter a list returns the first list element in list format
files[1]
glimpse(files[1])

# Using double square brackets returns the first list element only, so it removes the list structure and shows the original data structure of that element (here a vector)
files[[1]]
glimpse(files[[1]])

```

Lists can also have named elements, which makes it possible to access elements by name.
```{r}

# Make a named list of the custom file names to write out
files <- list(
  `RFID` = c("RFID_simulated_Pair-01_2023_08_01.csv", "RFID_simulated_Pair-01_2023_08_02.csv", "RFID_simulated_Pair-01_2023_08_03.csv"),
  `IRBB` = c("IRBB_simulated_Pair-01_2023_08_01.csv", "IRBB_simulated_Pair-01_2023_08_02.csv", "IRBB_simulated_Pair-01_2023_08_03.csv")
)

glimpse(files)

```

Access the list elements by name:
```{r}

# Using a single bracket returns the first element as a list, called "RFID"
files["RFID"]

# Using the dollar sign or double square brackets returns the first list element in its original format
files$RFID

files[["RFID"]]

```

Lists are very useful data structures for setting up nested loop operations. For instance, if you want to write out a spreadsheet per day per sensor type, you need a loop to 1) iterate over sensor types, and then a loop to 2) iterate over days per sensor. You can use lists to create nested data structures to supply to a nested loop, which will help you make sure that each layer of the loop runs in the way that you expect. For instance, the list called `files` reflects the nested loop that you need because files are listed first by sensor type (each element of the list) and then by date (each element of the vector inside of each list element):
```{r}

# Make a vector of sensor labels
sensors <- c("RFID", "IRBB")

sensors

# Make a named list of the custom file names to write out
files <- list(
  `RFID` = c("RFID_simulated_Pair-01_2023_08_01.csv", "RFID_simulated_Pair-01_2023_08_02.csv", "RFID_simulated_Pair-01_2023_08_03.csv"),
  `IRBB` = c("IRBB_simulated_Pair-01_2023_08_01.csv", "IRBB_simulated_Pair-01_2023_08_02.csv", "IRBB_simulated_Pair-01_2023_08_03.csv")
)

files

# Make a list of file paths per sensor that will be used inside of the loop
file_dirs <- list(
  `RFID` = file.path(path, "Data/RFID"),
  `IRBB` = file.path(path, "Data/IRBB") 
)

file_dirs

# Make a list of the days to write out for each sensor
# This could be a single vector rather than a list since you want to write out the same days per sensor, but a list is useful in case you wanted to change the days (and number of days) to write out per sensor
days <- list(
  `RFID` = c(1, 2, 3),
  `IRBB` = c(1, 2, 3)
)

days

# Finally, you need to make a list of the data frames that you want to write out. Since you already know how to filter data frames by day, that code can go inside of the loop. Here you can specify the data frame to use in the filtering operation per sensor type
dats <- list(
  `RFID` = sim_dats_rfid,
  `IRBB` = sim_dats_irbb
)

glimpse(dats)

```

Once you've set up the data structures that you want to loop over, you can write out the nested loop itself. Since this is a complex loop structure, it can be helpful to test the loop with set values of each iterating variable (below these will be `x` and `y`). 

After writing out this loop but before running the full loop structure, you should test the code inside of each loop layer. To do this, you can set the values of each iterating variable outside of the loop and then run the code inside of each loop. This form of testing is equivalent to freezing the loop in time, so that you're seeing the output of the code for a single loop iteration (below, the first iteration for each loop layer when `x` and `y` are both set to 1).

To carry out this type of testing, you should run the code to freeze the iterating variables on the first iteration of each loop. Then, you should run the code inside of each loop, starting with the creation of `days_tmp`, then the indexing and filtering the data frame, and then the filtering of the file names. You should not run either of the lines with `lapply()` in them, since you don't want either loop to fully execute before you're sure that the inner code is working as expected.

As you test the code inside of each loop, you should see that between the outer and inner loops, you're using the name of the sensor for the given outer loop iteration ("RFID" for the first iteration) to set up the days over which the inner loop will iterate (in `days_tmp`). Inside of the inner loop, you're filtering the list of data frames by sensor, and then by the days that you want per sensor. Finally, you're indexing the file name for the right sensor type and day with a combination of double and single bracket filtering on the list of file names:
```{r eval = FALSE}

# Testing
x <- 1
y <- 1

# Start by iterating over sensors
invisible(lapply(1:length(sensors), function(x){
  
  # Index the named list of days to get the right days per sensor
  # This indexing is important to set up the next loop correctly
  
  sensors[x] # This is a string with the sensor name
  
  # Place the string with the sensor name inside of double square brackets to extract the vector of days for that sensor 
  days_tmp <- days[[sensors[x]]]
  
  days_tmp
  
  # For each sensor, iterate over days
  lapply(1:length(days_tmp), function(y){
    
    # Get the data frame per sensor type using x inside of double square brackets to extract the given data frame from the list
    dats[[x]] %>%
      # Filter the data frame by one day at a time by using y to index the temporary vector of days (e.g. to extract a single element from that vector)
      dplyr::filter(day == days_tmp[y]) %>% 
      glimpse()
    
    # Use double bracket filtering to pull out the vector of file names for the given sensor from the overall list, then use y with single bracket filtering to pull a single file name from the resulting vector of names
    files[[x]]
    
    files[[x]][y]
    
    # You'll also combine the file name with the right path:
    file.path(file_dirs[[x]], files[[x]][y])
    
  })
  
}))

```

You should have a better sense now of how each loop operates over different data structures to carry out the operation that you want (writing out a single spreadsheet per sensor type and day). Next, you can modify the full loop to replace the lines written for testing with the final operations that you want to carry out: 
```{r eval = FALSE}

# Start by iterating over sensors
invisible(lapply(1:length(sensors), function(x){
  
  # Index the list of days to get the right days per sensor
  # This indexing is important to set up the next loop correctly
  days_tmp <- days[[sensors[x]]]
  
  # For the given sensor, iterate over days of data collection to write out a spreadsheet per sensor and day
  lapply(1:length(days_tmp), function(y){
    
    # Get the data frame per sensor type using x and then filter by day using y
    dats[[x]] %>%
      # Filter the data frame by one day at a time
      dplyr::filter(day == days_tmp[y]) %>%
      # Use double-bracket filtering to pull out the right file path per sensor
      # Then use double and single bracket filtering to pull out the right file name per sensor and day
      write.csv(file = file.path(file_dirs[[x]], files[[x]][y]), row.names = FALSE)
    
  })
  
}))

```

This loop should have created 1 file per sensor and day in the correct directory per sensor. Check that these 4 files now exist inside each directory per sensor within your working directory.
```{r eval = FALSE}

list.files(file.path(path, "Data/RFID"))

list.files(file.path(path, "Data/IRBB"))

```

You learned more about filtering data frames, writing them out to spreadsheets, and writing single-layer and nested loops in this vignette. In the next vignette, you'll use the spreadsheets of simulated RFID and IRBB data to start the ABISSMAL data processing and analysis workflow.