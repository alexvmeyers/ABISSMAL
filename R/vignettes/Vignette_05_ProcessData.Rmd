---
title: "Vignette 05: Process Data"
author: "Grace Smith-Vidaurre"
date: "2023-12-27"
output: html_document
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

<h2>Vignette Overview and Learning Objectives</h2>

In this fourth vignette, you will write out spreadsheets of simulated detections of animal movements to your computer. You'll begin using this data in the ABISSMAL data processing and analysis workflow, including combining raw data across days and pre-processing the raw data. You will continue to use coding skills that you learned in the previous vignettes, and you will learn additional skills that include:

1. Accessing custom functions
2. Using custom functions
3. Plotting data with ggplot

<h2>Load packages and your working directory path</h2>

```{r message = FALSE, warning = FALSE}

rm(list = ls()) # Clean global environment

library(tidyverse) # Load the set of tidyverse packages
library(data.table) # Load other packages that the ABISSMAL functions require

# Initialize an object with the path that is your working directory
path <- "/home/gsvidaurre/Desktop/ABISSMAL_vignettes"

```

<h2>Load ABISSMAL functions</h2>

The custom R functions available through the ABISSMAL GitHub repository are stored in physical files (extension .R) inside the local repository on your computer (which you should have downloaded in vignette 01). In order to start using the ABISSMAL functions, you need to load the physical .R files so that the functions are available in your global environment. In the code below, you will use the function `source()` to load 3 of the 5 main ABISSMAL functions, plus a script that holds a set of utility functions:
```{r}

# Load the function that combines raw data
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/combine_raw_data.R")

# Load the function that detects perching events in the raw data
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/detect_perching_events.R")

# Load the function that pre-processes raw data
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/preprocess_detections.R")

# Load a script with utility functions that each function above requires
source("/home/gsvidaurre/Desktop/GitHub_repos/ABISSMAL/R/utilities.R")

```

<h2>Access ABISSMAL function information</h2>

After running the lines of code above, you should see that a whole set of functions have been loaded into your global environment (check the `Environment` pane). Many of these functions start with `check_`, and those are utility functions. If you scroll down, you'll see that the three main functions above (`combine_raw_data`, `detect_perching_events`, `preprocess_detections`) are all loaded in your global environment. In the column to the right of the function names you can also see a preview of each function's arguments. 

To get more information about each of these three main functions, you can click the white square icon to the very right of each function in the `Environment` pane, or run the code `View(function_name)`. This will open the script for the given function a new tab in your Source pane. In each script for each function, you'll see lines of documentation starting with the symbols "`# @". You'll see the function name and description first, and then a description of each argument (parameter) for the function. If you keep scrolling down, you'll see a section with details about how the given function works, and the information that it returns. After the lines of documentation, you'll see the code that makes up the function itself. 

<h2>Combine raw data</h2>

Once you've loaded the ABISSMAL functions, you can start using the first function, `combine_raw_data()`, to combine data collected across days per sensor into a single spreadsheet per sensor. You'll start by combining raw data for the RFID sensor collected over different days into a single spreadsheet.

Here goes more information about the arguments you are supplying to the function below:

* `sensors` is a vector containing the labels of the sensors for which you want to combine raw data. Below you're specifying RFID as a single sensor

* `path` is your general working directory

* `data_dir` is the folder that holds data inside of your working directory

* `out_dir` is the folder where you want to save the combined raw data spreadsheet. The function will create this folder if it does not already exist

* `tz` is the timezone for converting timestamps to POSIXct format. The default is "America/New York", and you can check out the "Time zones" section in the documentation for DateTimeClasses in R for more information (`?DateTimeClasses`)

* `POSIXct_format` is a string containing the POSIX formatting information for how dates and timestamps should be combined into a single column. The default is to encode the year as a 4 digit number and the month and day as 2 digit numbers, separated by dashes. The date is followed by a space, then the 2-digit hour, minute, and decimal second (separated by colons)
```{r}

combine_raw_data(sensors = "RFID", path = path, data_dir = "Data", out_dir = "Data/raw_combined", tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")

```

You can check that `combine_raw_data()` wrote a single spreadsheet of raw RFID data to the new directory `raw_combined`:
```{r}

list.files(file.path(path, "Data/raw_combined"), pattern = ".csv$")

```

You can read this combined .csv file (called "combined_raw_data_RFID.csv") back into R to check out the structure of this spreadsheet:
```{r}

rfid_data <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_RFID.csv"))

glimpse(rfid_data)

```

You should be able to see that there are some new columns created by the function, such as the column `data_type`. For this spreadsheet, the columns `sensor_id` and `data_type` contain the same information, but it's useful to have separate columns to keep track of the sensor id and type of sensor used to collect data when multiple sensors are used (e.g. two beam breaker pairs will each hace a unique identifier in `sensor_id`).

The function created a new timestamps column in POSIXct format for downsteam processing and analysis, but it kept the original timestamps column. The function also added columns to indicate the stage of data processing and the date that the raw data were combined. Finally, if you check the folders with the original raw RFID data, you'll see that the original spreadsheets per day were retained and not removed not overwritten.

You can also run `combine_raw_data()` with raw data from multiple sensors by supplying a vector with the sensor labels to the argument `sensors`:
```{r}

combine_raw_data(sensors = c("RFID", "IRBB"), path = path, data_dir = "Data", out_dir = "Data/raw_combined", tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")

```

The RFID data will be overwritten, and you should see an additional spreadsheet with the raw IRBB data:
```{r}

list.files(file.path(path, "Data/raw_combined"), pattern = ".csv$")

```

<h2>Detect perching events</h2>

You can use the combined raw data from different sensors in subsequent ABISSMAL functions to start making behavioral inferences from events in the movement detection datasets. For instance, you can detect perching events in the raw RFID data with the function `detect_perching_events()`. You can read more about each argument in the R script that contains this function.
```{r}

detect_perching_events(file_nm = "combined_raw_data_RFID.csv", threshold = 2, run_length = 2, sensor_id_col_nm = "sensor_id", timestamps_col_nm = "timestamp_ms", PIT_tag_col_nm = "PIT_tag", rfid_label = "RFID", general_metadata_cols = c("chamber_id", "sensor_id"), path = file.path(path, "Data"), data_dir = "raw_combined", out_dir = "processed", out_file_prefix = "perching_events", tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")

```

`detect_perching_events()` can only operate on a single file and sensor type at a time. The function will automatically create a new folder called "processed", and will save the .csv inside of that folder with perching events (if these were detected using the temporal threshold and run length above). 

When we simulated data in the third and fourth vignettes, you simulated perching events in the RFID dataset only. Did the code above recover those perching events?
```{r}

perching <- read.csv(file.path(path, "Data", "processed", "perching_events_RFID.csv"))

glimpse(perching)

```

`detect_perching_events()` identified 4 total perching events, which is the same number that you simulated in the previous vignette. You can look at the values inside of data frame for more information about these perching events:
```{r}

# The timestamps when each perching event started
perching$perching_start

# The timestamps when each perching event ended
perching$perching_end

# The unique PIT tag identifier that tells you which individual was perched on the RFID antenna
perching$PIT_tag

```

The information above tells you that there were 2 perching events detected at 8:00 each day, and 2 perching events detected at 11:30 each day (as expected). The PIT tag for each individual was detected once each day, so there was 1 perching event performed by each individual on each day.

Detecting perching events is not a requirement in the ABISSMAL workflow, but it can be a useful step to obtain as much information from the raw data before some detections are dropped during pre-processing (see below).

<h2>Pre-process raw data</h2>

Once you've detected perching events in the raw data, you can move on to pre-processing the raw data itself with `preprocess_detections()`. The raw data can sometimes contain multiple detections separated by a short period of time (e.g. RFID detections when an individual is perching on the antenna), and these multiple detections can be a source of noise when you're trying to make behavioral inferences across data collected by multiple sensors. When the argument `mode` is set to "thin", `preprocess_detections()` removes detections separated by a very short period of time, and retains a reduced datasets of detections that still represents discrete movement events.

`preprocess_detections()` also operates on a single sensor type at a time:
```{r}

preprocess_detections(sensor = "RFID", timestamps_col_nm = "timestamp_ms", group_col_nm = "PIT_tag", mode = "thin", thin_threshold = 2, drop_tag = NULL, path = file.path(path, "Data"), data_dir = "raw_combined", out_dir = "processed", tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")

```

You should now see an additional .csv file called "pre_processed_data_RFID.csv" in the "processed" folder:
```{r}

list.files(file.path(path, "Data/processed"))

```

You can read this file into R to check out the data structure. You should see that there are fewer rows here compared to the spreadsheet of raw data:
```{r}

rfid_pp <- read.csv(file.path(path, "Data/processed/pre_processed_data_RFID.csv"))

glimpse(rfid_pp)

```

Next, you can pre-process the raw beam breaker data and check out the resulting .csv file:
```{r}

preprocess_detections(sensor = "IRBB", timestamps_col_nm = "timestamp_ms", group_col_nm = "sensor_id", mode = "thin", thin_threshold = 2, drop_tag = NULL, path = file.path(path, "Data"), data_dir = "raw_combined", out_dir = "processed", tz = "America/New York", POSIXct_format = "%Y-%m-%d %H:%M:%OS")

list.files(file.path(path, "Data/processed"))

irbb_pp <- read.csv(file.path(path, "Data/processed/pre_processed_data_IRBB.csv"))

glimpse(irbb_pp)

```

<h2>Plot raw and pre-processed data</h2>

Now that you've combined the raw data per sensor, detected perching events in the raw data, and pre-processed the raw data, it's time to visualize these different datasets. Making visualizations in R is important for generating high-quality figures for publications and presentations, but it's also important for checking your work as you process and analyze data.

In the code below, you'll learn how to use functions from the `ggplot2` package to make barcode style visualizations of the raw and processed detection datasets.

Start by reading in the raw data for each sensor, and convert the timestamps to POSIX format.
```{r}

rfid_raw <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_RFID.csv")) %>%
  # The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
  dplyr::mutate(
    timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
  )

# You should see that the timestamp_ms is in "dttm" format, which means that the POSIX conversion was done correctly
glimpse(rfid_raw)

irbb_raw <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_IRBB.csv")) %>%
  # The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
  dplyr::mutate(
    timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
  )

glimpse(irbb_raw)

```

Next, start plotting this raw data using functions from `ggplot2`. This package is part of the `tidyverse`, but can also be installed and used separately. You can check out this [link](https://ggplot2.tidyverse.org/) for more resources to learn how to use ggplot to make different types of plots. These resources include sections of three different books with hands-on exercises at different levels, as well as an online course and a webinar.

Thde `ggplot2` package has a unique syntax for building plots, in which you start making a plot by calling the function `ggplot()`, and then add features by layering on other `ggplot2` functions with the `+` symbol.

If you call `ggplot()`, you'll see that the function immediately draws a blank plot in your Plots pane in RStudio.
```{r}

ggplot()

```

The plot will still remain blank even if you supply information about your data in order to set up plot aesthetics.
```{r}

ggplot(data = rfid_raw)

```

The functions that you use to layer aesthetics over the empty plot will depend on the type of plot that you want to make. For this example, you will make a barcode style plot, in which each timestamp is shown as a thin vertical line. Barcode plots can be useful visualizations when you're working with timestamps, since the most important information is contained in one dimension (time on the x-axis). If you were to summarize the number of timestamps recorded on each day, then you could create a line plot instead (see a plot in the next vignette).

You can layer the function `geom_segment()` over the base plot layer. `geom_segment()` allows you to add lines to a plot, and the lines can communicate information in one or two dimensions (width on the x-axis and height on the x-axis). In the plot you'll make below, you'll use `geom_segment()` to add lines to the plot that contain temporal information in one dimension (timestamps, information on the x-axis only).
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1),
    color = "blue",
    linewidth = 0.3
  )
  
```

In the code above, you used the argument `data` inside of `geom_segment()` to tell the function where to get data for drawing the line segments. 

In the argument `aes()`, which is a standard `ggplot2` function for encoding plot aesthetics, you specified that the data to plot on the x-axis are the timestamps for each detection, by providing the column name `timestamp_ms` to the inner argument `x`. You also specified what data should be plotted on the y-axis using the argument `y`. In this case, you can set `y` to any value that you want, since you aren't plotting data along this axis.

The arguments `x` and `y` determine where the beginning of each line is drawn on the x and y-axes, respectively. You also need to specify where you want the line segment to **end** on each axis. On the x-axis, by supplying the column name `timestamp_ms` to the argument `xend`, you're indicating that you want the line segment to start and end on the same timestamp. On the y-axis, the number that you supply to `yend` will determine the height of each line. Since you're adding data from a single sensor here, the height of the line does not matter much. If you changed the code to read `yend = 0.1`, the plot would look very similar, but the y-axis would be scaled to have 0.1 as the maximum value instead of 1.

The last two arguments inside of `geom_segment()` control the color of the line segments (`color`), as well as the width of ech line (`linewidth`). Specifying the width of each line is different than specifying where each line segment starts and ends.

You can continue adding information to this plot by layering on the raw beam breaker detections:
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 1),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  geom_segment(
    data = irbb_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 1),
    color = "orange",
    linewidth = 0.3
  )

```

This plot has more information, but it's difficult to interpret. Some of the detections for each sensor type occurred so close in time that they're layered nearly directly over one another. You can change where the line segements per sensor start and end on the y-axis in order to have better temporal resolution for visualizng the datasets from both sensors.

```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  geom_segment(
    data = irbb_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  )
  
```

This change to the start and end coordinates of how segments are drawn on the y-axis offset the two sets of line segments per sensor dataset. The plot is now less crowded and it's easier to visualize patterns over time and between datasets now.

The plot is looking a lot better, but there's a problem with the x-axis. The x-axis currently holds two types of information: 1) the day of data collection, and 2) the time of day. It's difficult to see when detections were recorded on each day, and whether detections were recorded over similar or different time periods between days. To make the x-axis more interpretable, you can change the plot to be "faceted", so that you have 1 panel per day of data collection.
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  geom_segment(
    data = irbb_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  facet_wrap(~ day, nrow = 2, strip.position = "left")

```

The overall plot structure has improved a lot, but are still some modifications that would help interpretability. First, the panel or facet labels on the left could be changed from the date to the day of data collection (e.g. "Day 1"). The x-axis labels could also be changed to show only the time of day (remove the month and day), and there could also be more labels available (e.g. label each hour).

You can start by modifying the data frame of raw data for each senor to add information about the day of data collection. You'll create this new column by relying on conditional statements with the `ifelse()` function, since there are only 2 days of data collection that need recoding.

First you can practice using `ifelse()` to create a new vector. In the code below, you're providing the conditional statement that you want to test (here you're testing whether the day is the first day of the month), the value you want to add to the vector if the condition is true ("Day 1" of data collection), and then the value that you want to add if the condition is false ("Day 2" of data collection, since there are only 2 dates in each dataset). 
```{r}

ifelse(test = rfid_raw$day == 1, yes = "Day 1", no = "Day 2")

```

Now you can create a new column per data frame using an `ifelse` statement. 
```{r}

# Create a new column in the raw data for the date of data collection
rfid_raw2 <- rfid_raw %>% 
  dplyr::mutate(
    day_label = ifelse(day == 1, "Day 1", "Day 2")
  )
  
# You should see that the new column "day_label" was created
# You'll see that a new year, month, and day were appended to the updated timestamps, but this is expected (see above)
glimpse(rfid_raw2)

# Repeat this process for the beam breaker data
irbb_raw2 <- irbb_raw %>% 
  dplyr::mutate(
    day_label = ifelse(day == 1, "Day 1", "Day 2")
  )

glimpse(irbb_raw2)

```

Now you can update the code to include the new date labels:
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw2,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw2,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left")

```

Now that information about the day of data collection has been moved to the facet labels, you need to fix the x-axis labels. The plot will be more interpretable if you can line up the timestamps by hour and minute for a direct comparison across days.  

To line up the timestamps across days, you will need to update the format of the timestamps column. The code to convert the timestamps to a different format is nested and repetitive, but the timestamp conversion will be performed correctly. When you prompt the R to convert the timestamps to hours, minutes, and seconds only, R adds a default year, month, and day beforehand (likely the current date that you rant the code). This is expected, and it is not an error, but rather makes it possible for the timestamps to align correctly over days in the plot (since R sees all timestamps occurring on a single day).
```{r}

rfid_raw3 <- rfid_raw2 %>% 
  dplyr::mutate(
    timestamp = as.POSIXct(strptime(format(as.POSIXct(timestamp_ms), "%H:%M:%S"), format = "%H:%M:%S"))
  )
  
# You'll see that a new year, month, and day were appended to the updated timestamps, but this is expected (see above)
glimpse(rfid_raw3)

# Repeat this process for the beam breaker data
irbb_raw3 <- irbb_raw2 %>% 
  dplyr::mutate(
    timestamp = as.POSIXct(strptime(format(as.POSIXct(timestamp_ms), "%H:%M:%S"), format = "%H:%M:%S"))
  )

glimpse(irbb_raw3)

```

Now you can update the plotting code to change the aesthetics of the x-axis using the function `scale_x_datetime()` to specify that you want x-axis labels every half hour:
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +

  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  )

```

You can make some minor adjustments to the plot to make it easier on the eyes, including changing the axis titles to be more informative, changing the background to be white, and removing the y-axis text and axis ticks (since the height of each segment does not reflect data that you want to interpret).
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +
  
  # Change the x and y axis labels
  xlab("Time") +
  
  # Now you can add a y-axis label
  ylab("Day of data collection") +
  
  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  ) +
  
  # Use this function to convert the plot background to black and white
  theme_bw() +
  
  # Use aesthetics functions to remove the y-axis labels and ticks
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )

```

Finally, you need to add a legend to this plot so you can communicate what the two different colors mean. Adding a legend to this plot is tricky because you manually coded the colors of the line segments in two separate uses in `geom_segment()`. `ggplot2` functions have specific requirements for making a legend, and they can require automated coding of aesthetic values like color.

In order to automatically create a legend in a plot, it helps to have a layer of the plot in which color is automatically encoded. The way that you would do this is to move the `color` argument inside of the function `aes()` for one layer of the plot, and then supply `color` with a column of data type `factor`...TKTK continue
```{r}

all_sensors <- rfid_raw3 %>%
  bind_rows(
    irbb_raw3
  ) %>% 
  dplyr::mutate(
    sensor_id = factor(sensor_id)
  )

glimpse(all_sensors)

```

Then make the plot...TKTK split up creating the legend a bit more (e.g. default colors first)
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Add the fake layer of lines so that you can create a legend
  # The argument color here must be supplied with the name of a column that is the data type "factor" in R. This will trigger automatic coding of the color values that you specify below
  geom_line(data = all_sensors, aes(x = timestamp, y = 1, color = sensor_id), linewidth = 0) +

  # Set the colors that will be used to color the lines in the legend itself
  # The length of the vector of color values that you supply here must be the same length as the number of "levels" (or unique values) in the factor column
  # If you do not supply your own color values, then R will assign default colors to each factor level 
  scale_color_manual(values = c("blue", "orange")) +

  # Specify that you want to create a color legend, and override the linewidth of 0 above so that the lines show up in the legend. You can also customize the legend title, otherwise it will use the column name linked to the color encoding
  guides(color = guide_legend(override.aes = list(linewidth = 2), title = "Sensor type")) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +
  
  # Change the x and y axis labels
  xlab("Time") +
  
  # Now you can add a y-axis label
  ylab("Day of data collection") +
  
  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  ) +
  
  # Use this function to convert the plot background to black and white
  theme_bw() +
  
  # Use aesthetics functions to remove the y-axis labels and ticks
  # Add an argument to change where the legend is located in the plot
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )

```



Then...TKTK add a legend, write out a plot as an image file. More modification to get font size right

```{r}

  ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = raw_rfid,
    aes(x = timestamp, y = 0, xend = timestamp, yend = y_max/4),
    color = cols[4],
    linewidth = 0.3
  ) +
  
  geom_segment(
    data = raw_all2 %>% 
      dplyr::filter(sensor_id == "Inner Beam Breaker"),
    aes(x = timestamp, xend = timestamp, y = y_max/4, yend = (y_max/4) * 2),
    color = cols[3],
    linewidth = 0.3
  ) +
  
  geom_segment(
    data = raw_all2 %>% 
      dplyr::filter(sensor_id == "RFID"),
    aes(x = timestamp, xend = timestamp, y = (y_max/4) * 2, yend = (y_max/4) * 3),
    color = cols[2],
    linewidth = 0.3
  ) +
  
  geom_segment(
    data = raw_all2 %>% 
      dplyr::filter(sensor_id == "Outer Beam Breaker"),
    aes(x = timestamp, xend = timestamp, y = (y_max/4) * 3, yend = y_max),
    color = cols[1],
    linewidth = 0.3
  ) +
  
  # I removed switch = "y" because it's possible to rotate strip lables horizontally when they're on the right
  facet_grid(rows = vars(new_date)) +
  
  # Add shaded rectangles for the nocturnal periods
  geom_rect(data = rect_df2, aes(xmin = time_xmin, xmax = time_xmax, ymin = -Inf, ymax = Inf), color = alpha("black", 0), fill = alpha("black", 0.08), inherit.aes = FALSE) +
  
  scale_x_datetime(
    breaks = seq(x_lims[1], x_lims[2], "1 hour"),
    date_labels = "%H:%M",
    expand = c(0, 0),
    limits = x_lims
  ) +

  scale_y_continuous(limits = c(0, y_max)) +
  guides(color = "none") +
  theme_bw() +
  ylab("") +
  xlab("") +
  theme(
    axis.ticks.y = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(size = 7, angle = 90, vjust = 0.5, hjust = 0.5, color = "black"),
    strip.text.y = element_text(size = 7, face = "bold", angle = 0),
    strip.background = element_rect(fill = "white"),
    legend.position = "top",
    axis.ticks = element_line(linewidth = 0.25)
  )


```


