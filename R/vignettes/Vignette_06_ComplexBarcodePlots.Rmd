---
title: "Vignette 05: Process Data"
author: "Grace Smith-Vidaurre"
date: "2023-12-27"
output: html_document
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = TRUE)

```

<h2>Vignette Overview and Learning Objectives</h2>

In this fifth vignette, you will begin using the simulated detections of animal movements in the ABISSMAL data processing and analysis workflow, including combining raw data across days and pre-processing the raw data. You will also make visualizations of the processed data. You will continue to use coding skills that you learned in the previous vignettes, and you will learn additional skills that include:

1. Accessing custom functions
2. Using custom functions
3. Plotting data with ggplot

<h2>Load packages and your working directory path</h2>

```{r message = FALSE, warning = FALSE}

rm(list = ls()) # Clean global environment

library(tidyverse) # Load the set of tidyverse packages
library(data.table) # Load other packages that the ABISSMAL functions require

# Initialize an object with the path that is your working directory
path <- "/home/gsvidaurre/Desktop/ABISSMAL_vignettes"

```

<h2>Plot raw and pre-processed data</h2>

Now that you've combined the raw data per sensor, detected perching events in the raw data, and pre-processed the raw data, it's time to visualize these different datasets. Making visualizations in R is important for generating high-quality figures for publications and presentations, but it's also important for checking your work as you process and analyze data.

In the code below, you'll learn how to use functions from the `ggplot2` package to make barcode style visualizations of the raw and processed detection datasets.

Start by reading in the raw data for each sensor, and convert the timestamps to POSIX format.
```{r}

rfid_raw <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_RFID.csv")) %>%
  # The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
  dplyr::mutate(
    timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
  )

# You should see that the timestamp_ms is in "dttm" format, which means that the POSIX conversion was done correctly
glimpse(rfid_raw)

irbb_raw <- read.csv(file.path(path, "Data/raw_combined", "combined_raw_data_IRBB.csv")) %>%
  # The timestamps must be converted to POSIX format every time that the data is read back into R for plotting
  dplyr::mutate(
    timestamp_ms = as.POSIXct(format(as.POSIXct(timestamp_ms, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
  )

glimpse(irbb_raw)

```

Next, start plotting this raw data using functions from `ggplot2`. This package is part of the `tidyverse`, but can also be installed and used separately. You can check out this [link](https://ggplot2.tidyverse.org/) for more resources to learn how to use ggplot to make different types of plots. These resources include sections of three different books with hands-on exercises at different levels, as well as an online course and a webinar.

Thde `ggplot2` package has a unique syntax for building plots, in which you start making a plot by calling the function `ggplot()`, and then add features by layering on other `ggplot2` functions with the `+` symbol.

If you call `ggplot()`, you'll see that the function immediately draws a blank plot in your Plots pane in RStudio.
```{r}

ggplot()

```

The plot will still remain blank even if you supply information about your data in order to set up plot aesthetics.
```{r}

ggplot(data = rfid_raw)

```

The functions that you use to layer aesthetics over the empty plot will depend on the type of plot that you want to make. For this example, you will make a barcode style plot, in which each timestamp is shown as a thin vertical line. Barcode plots can be useful visualizations when you're working with timestamps, since the most important information is contained in one dimension (time on the x-axis). If you were to summarize the number of timestamps recorded on each day, then you could create a line plot instead (see a plot in the next vignette).




TKTK the code below complicates adding a legend. Consider this code to be a more complex version of the figure...maybe save for another script? And here add just a single sensor

You can layer the function `geom_segment()` over the base plot layer. `geom_segment()` allows you to add lines to a plot, and the lines can communicate information in one or two dimensions (width on the x-axis and height on the x-axis). In the plot you'll make below, you'll use `geom_segment()` to add lines to the plot that contain temporal information in one dimension (timestamps, information on the x-axis only).
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, y = 0, xend = timestamp_ms, yend = 1),
    color = "blue",
    linewidth = 0.3
  )
  
```

In the code above, you used the argument `data` inside of `geom_segment()` to tell the function where to get data for drawing the line segments. 

In the argument `aes()`, which is a standard `ggplot2` function for encoding plot aesthetics, you specified that the data to plot on the x-axis are the timestamps for each detection, by providing the column name `timestamp_ms` to the inner argument `x`. You also specified what data should be plotted on the y-axis using the argument `y`. In this case, you can set `y` to any value that you want, since you aren't plotting data along this axis.

The arguments `x` and `y` determine where the beginning of each line is drawn on the x and y-axes, respectively. You also need to specify where you want the line segment to **end** on each axis. On the x-axis, by supplying the column name `timestamp_ms` to the argument `xend`, you're indicating that you want the line segment to start and end on the same timestamp. On the y-axis, the number that you supply to `yend` will determine the height of each line. Since you're adding data from a single sensor here, the height of the line does not matter much. If you changed the code to read `yend = 0.1`, the plot would look very similar, but the y-axis would be scaled to have 0.1 as the maximum value instead of 1.

The last two arguments inside of `geom_segment()` control the color of the line segments (`color`), as well as the width of ech line (`linewidth`). Specifying the width of each line is different than specifying where each line segment starts and ends.

You can continue adding information to this plot by layering on the raw beam breaker detections:
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 1),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  geom_segment(
    data = irbb_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 1),
    color = "orange",
    linewidth = 0.3
  )

```

This plot has more information, but it's difficult to interpret. Some of the detections for each sensor type occurred so close in time that they're layered nearly directly over one another. You can change the position of the line segements on the y-axis in order to have better resolution for visualizng the datasets from both sensors.

```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  geom_segment(
    data = irbb_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  )
  
```

This change to the start and end coordinates of how segments are drawn on the y-axis offset the two sets of line segments per sensor dataset. The plot is now less crowded and it's easier to visualize patterns over time and between datasets now.

The plot is looking a lot better, but there's a problem with the x-axis. The x-axis currently holds two types of information: 1) the day of data collection, and 2) the time of day. It's difficult to see when detections were recorded on each day, and whether detections were recorded over similar or different time periods between days. To make the x-axis more interpretable, you can change the plot to be "faceted", so that you have 1 panel per day of data collection.
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  geom_segment(
    data = rfid_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  geom_segment(
    data = irbb_raw,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  facet_wrap(~ day, nrow = 2, strip.position = "left")

```

The overall plot structure has improved a lot, but are still some modifications that would help interpretability. First, the panel or facet labels on the left could be changed from the date to the day of data collection (e.g. "Day 1"). The x-axis labels could also be changed to show only the time of day (remove the month and day), and there could also be more labels available (e.g. label each hour).

You can start by modifying the data frame of raw data for each senor to add information about the day of data collection. You'll create this new column by relying on conditional statements with the `ifelse()` function, since there are only 2 days of data collection that need recoding.

First you can practice using `ifelse()` to create a new vector. In the code below, you're providing the conditional statement that you want to test (here you're testing whether the day is the first day of the month), the value you want to add to the vector if the condition is true ("Day 1" of data collection), and then the value that you want to add if the condition is false ("Day 2" of data collection, since there are only 2 dates in each dataset). 
```{r}

ifelse(test = rfid_raw$day == 1, yes = "Day 1", no = "Day 2")

```

Now you can create a new column per data frame using an `ifelse` statement. 
```{r}

# Create a new column in the raw data for the date of data collection
rfid_raw2 <- rfid_raw %>% 
  dplyr::mutate(
    day_label = ifelse(day == 1, "Day 1", "Day 2")
  )
  
# You should see that the new column "day_label" was created
# You'll see that a new year, month, and day were appended to the updated timestamps, but this is expected (see above)
glimpse(rfid_raw2)

# Repeat this process for the beam breaker data
irbb_raw2 <- irbb_raw %>% 
  dplyr::mutate(
    day_label = ifelse(day == 1, "Day 1", "Day 2")
  )

glimpse(irbb_raw2)

```

Now you can update the code to include the new date labels:
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw2,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw2,
    aes(x = timestamp_ms, xend = timestamp_ms, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left")

```

Now that information about the day of data collection has been moved to the facet labels, you need to fix the x-axis labels. The plot will be more interpretable if you can line up the timestamps by hour and minute for a direct comparison across days.  

To line up the timestamps across days, you will need to update the format of the timestamps column. The code to convert the timestamps to a different format is nested and repetitive, but the timestamp conversion will be performed correctly. When you prompt the R to convert the timestamps to hours, minutes, and seconds only, R adds a default year, month, and day beforehand (likely the current date that you rant the code). This is expected, and it is not an error, but rather makes it possible for the timestamps to align correctly over days in the plot (since R sees all timestamps occurring on a single day).
```{r}

rfid_raw3 <- rfid_raw2 %>% 
  dplyr::mutate(
    timestamp = as.POSIXct(strptime(format(as.POSIXct(timestamp_ms), "%H:%M:%S"), format = "%H:%M:%S"))
  )
  
# You'll see that a new year, month, and day were appended to the updated timestamps, but this is expected (see above)
glimpse(rfid_raw3)

# Repeat this process for the beam breaker data
irbb_raw3 <- irbb_raw2 %>% 
  dplyr::mutate(
    timestamp = as.POSIXct(strptime(format(as.POSIXct(timestamp_ms), "%H:%M:%S"), format = "%H:%M:%S"))
  )

glimpse(irbb_raw3)

```

Now you can update the plotting code to change the aesthetics of the x-axis using the function `scale_x_datetime()` to specify that you want x-axis labels every half hour:
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +

  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  )

```

You can make some minor adjustments to the plot to make it easier on the eyes, including changing the axis titles to be more informative, changing the background to be white, and removing the y-axis text and axis ticks (since the height of each segment does not reflect data that you want to interpret).
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +
  
  # Change the x and y axis labels
  xlab("Time") +
  
  # Now you can add a y-axis label
  ylab("Day of data collection") +
  
  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  ) +
  
  # Use this function to convert the plot background to black and white
  theme_bw() +
  
  # Use aesthetics functions to remove the y-axis labels and ticks
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )

```

Finally, you need to add a legend to this plot so you can communicate what the two different colors mean. Adding a legend to this plot is tricky because you manually coded the colors of the line segments in two separate uses in `geom_segment()`. `ggplot2` functions have specific requirements for making a legend, and they can require automated coding of aesthetic values like color.

In order to automatically create a legend in a plot, it helps to have a layer of the plot in which color is automatically encoded. The way that you would do this is to move the `color` argument inside of the function `aes()` for one layer of the plot, and then supply `color` with a column of data type `factor`...TKTK continue
```{r}

all_sensors <- rfid_raw3 %>%
  bind_rows(
    irbb_raw3
  ) %>% 
  dplyr::mutate(
    sensor_id = factor(sensor_id)
  )

glimpse(all_sensors)

```

Then make the plot.
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Add the fake layer of lines so that you can create a legend
  # The argument color here must be supplied with the name of a column that is the data type "factor" in R. This will trigger automatic coding of the color values that you specify below
  geom_line(data = all_sensors, aes(x = timestamp, y = 1, color = sensor_id), linewidth = 0) +

  # Specify that you want to create a color legend, and override the linewidth of 0 above so that the lines show up in the legend. You can also customize the legend title, otherwise it will use the column name linked to the color encoding
  guides(color = guide_legend(override.aes = list(linewidth = 2), title = "Sensor type")) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +
  
  # Change the x and y axis labels
  xlab("Time") +
  
  # Now you can add a y-axis label
  ylab("Day of data collection") +
  
  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  ) +
  
  # Use this function to convert the plot background to black and white
  theme_bw() +
  
  # Use aesthetics functions to remove the y-axis labels and ticks
  # Add an argument to change where the legend is located in the plot
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )

```

You added a legend to the plot, but the colors in the legend don't line up with the colors of the line segments per sensor. You can use the function `scale_color_manual()` to match colors between the plot and legend.
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Add the fake layer of lines so that you can create a legend
  # The argument color here must be supplied with the name of a column that is the data type "factor" in R. This will trigger automatic coding of the color values that you specify below
  geom_line(data = all_sensors, aes(x = timestamp, y = 1, color = sensor_id), linewidth = 0) +

  # Set the colors that will be used to color the lines in the legend itself
  # The length of the vector of color values that you supply here must be the same length as the number of "levels" (or unique values) in the factor column
  # If you do not supply your own color values, then R will assign default colors to each factor level 
  scale_color_manual(values = c("blue", "orange")) +

  # Specify that you want to create a color legend, and override the linewidth of 0 above so that the lines show up in the legend. You can also customize the legend title, otherwise it will use the column name linked to the color encoding
  guides(color = guide_legend(override.aes = list(linewidth = 2), title = "Sensor type")) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +
  
  # Change the x and y axis labels
  xlab("Time") +
  
  # Now you can add a y-axis label
  ylab("Day of data collection") +
  
  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  ) +
  
  # Use this function to convert the plot background to black and white
  theme_bw() +
  
  # Use aesthetics functions to remove the y-axis labels and ticks
  # Add an argument to change where the legend is located in the plot
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )

```

Now that you've made the plot in R, you can save the plot as an image file on your computer using the function `ggsave()`.
```{r}

ggplot() +
  
  # Add a vertical line for each RFID timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = rfid_raw3,
    aes(x = timestamp, xend = timestamp, y = 0, yend = 0.45),
    color = "blue",
    linewidth = 0.3
  ) +
  
  # Add a vertical line for each beam breaker timestamp
  # Use the new version of this data frame with the new day_label column
  # Make sure to use the new timestamp column
  geom_segment(
    data = irbb_raw3,
    aes(x = timestamp, xend = timestamp, y = 0.5, yend = 1),
    color = "orange",
    linewidth = 0.3
  ) +
  
  # Add the fake layer of lines so that you can create a legend
  # The argument color here must be supplied with the name of a column that is the data type "factor" in R. This will trigger automatic coding of the color values that you specify below
  geom_line(data = all_sensors, aes(x = timestamp, y = 1, color = sensor_id), linewidth = 0) +

  # Set the colors that will be used to color the lines in the legend itself
  # The length of the vector of color values that you supply here must be the same length as the number of "levels" (or unique values) in the factor column
  # If you do not supply your own color values, then R will assign default colors to each factor level 
  scale_color_manual(values = c("blue", "orange")) +

  # Specify that you want to create a color legend, and override the linewidth of 0 above so that the lines show up in the legend. You can also customize the legend title, otherwise it will use the column name linked to the color encoding
  guides(color = guide_legend(override.aes = list(linewidth = 2), title = "Sensor type")) +
  
  # Facet the plot by day (e.g. create a panel per day)
  # Use the new day labels here
  facet_wrap(~ day_label, nrow = 2, strip.position = "left") +
  
  # Change the x and y axis labels
  xlab("Time") +
  
  # Now you can add a y-axis label
  ylab("Day of data collection") +
  
  # Change the aesthetics of the x-axis labels
  scale_x_datetime(
    date_breaks = "30 mins",
    date_labels = "%H:%M"
  ) +
  
  # Use this function to convert the plot background to black and white
  theme_bw() +
  
  # Use aesthetics functions to remove the y-axis labels and ticks
  # Add an argument to change where the legend is located in the plot
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    legend.position = "top"
  )

# Save the image file to your computer
ggsave(file.path(path, "raw_detections.tiff"), width = 8, height = 6, units = "in", dpi = 300)

```

You just learned how to make a plot in R, and also how to save it to your computer. You can continue to modify minor aesthetics to this image file to create a high-quality figure for a publication. For instance, you can change the final size of the image file (`width`, `height`), as well as the resolution (`dpi`). You can also change the size of the text on each axis and the axis titles, or the legend position, as you play around with the final image size.