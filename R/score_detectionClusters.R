#' @title score_detectionClusters
#' @description Score clusters of detections to infer directionality
#' 
#' file_nm, sensor_id_col, timestamps_col, PIT_tag_col, general_metadata_cols, integrate_perching, path, data_dir, out_dir, out_file_nm = "scored_detectionBursts.csv", tz, POSIXct_format = "%Y-%m-%d %H:%M:%OS"
#' 
#' @param file_nm A character vector of length 1. This argument should be the name and extension of one .csv file that contains clusters detected using the function `find_detectionClusters`. For instance, c("detection_clusters.csv"). In this spreadsheet, each row should be a unique cluster of detections. The spreadsheet must contain all the columns specified in the subsequent arguments.
#' @param sensor_id_col A character string. This argument is the name of the metadata column that contains information about the data type (e.g. "sensor_id").
#' @param timestamps_col A character string. The name of the column that contains timestamps in a format that supports calculations in milliseconds (e.g. "timestamp_ms").
#' @param PIT_tag_col A character string. This argument is the name of the metadata column that contains information about the PIT tags detected by the RFID antenna (e.g. "PIT_tag_ID").
#' @param rfid_label A character string. This argument is the label for the RFID sensor in the sensor_id_col column in pre-processed data (e.g. "RFID").
#' @param camera_label A character string. This argument is the label for the camera sensor that records video in the sensor_id_col column in pre-processed data (e.g. "Camera").
#' @param outer_irbb_label A character string. This argument is the label for the outer pair of beam breakers in the sensor_id_col column in pre-processed data (e.g. "Outer Beam Breaker").
#' @param inner_irbb_label A character string. This argument is the label for the inner pair of beam breakers in the sensor_id_col column in pre-processed data (e.g. "Inner Beam Breaker").
#' @param preproc_metadata_cols A character vector. This argument should be a string of the metadata column names from pre-processing that should be dropped from either or both data frames. For instance, c("thin_threshold_s", "data_stage", "date_pre_processed", "lower_threshold_s", "upper_threshold_s", "date_labeled").
#' @param general_metadata_cols A character vector. This argument should be a string of the general metadata column names that will be carried through into the spreadsheet generated by this function. For instance: c("chamber_id", "year", "month", "day"). These columns will be added as the first columns in the integrated data frame, in the same order in which they are provided.
#' @param video_metadata_cols A character vector. This argument should be a string of the video metadata column names that will be carried through into the resulting data frame representing the integrated data. For instance: c("total_pixels_motionTrigger", "pixel_threshold", "video_file_name"). These columns will be added as later columns in resulting data frame, in the same order in which they were specified.
#' @param integrate_perching Boolean. If TRUE, then the perching events identified using `find_perching_events` will be integrated with this dataset. This integration is done by finding RFID timestamps that occurred within the duration of a perching event. If FALSE, then perching events will not be integrated.
#' @param path A character string. This argument should be the path on the local computer or external hard drive specifying where the data is saved across sensors for a given experimental setup. For instance, "/media/gsvidaurre/Anodorhynchus/Data_Testing/Box_02_31Dec2022/Data".
#' @param data_dir A character string. This argument should be the name of the directory where the pre-processed data that is used as input is saved inside the path above. For instance, "processed".
#' @param out_dir A character string. This argument should be the name of a directory specifying where the .csv file of integrated data should be saved. For instance, "integrated". This folder will be appended to the data_path and created as a new directory if it doesn't already exist.
#' @param out_file_nm A character string. The name (plus extension) of the resulting file that will be written to out_dir. The default is "scored_detectionClusters.csv"
#' @param tz A character string. This argument should contain the timezone used for converting timestamps to POSIXct format. For instance, "America/New York". See the base function `as.POSIXct` for more information.
#' @param POSIXct_format A character string. This argument should contain the format used to converting timestamps to POSIXct format. The default is "%Y-%m-%d %H:%M:%OS6" to return timestamps with milliseconds in decimal format. See the base function `as.POSIXct` for more information.
#' 
#' @details `score_detectionClusters` uses the order in which sensors triggered within clusters of detections identified by `find_detectionCusters`. The function finds edges or transitions between sensor labels in the sequence of detections for each cluster detected. Then, the function uses the order of the sensor labels in the first edge to label the directionality of movement events. `score_detectionClusters` was written for a hardware setup with multiple movement sensors (1 RFID antenna, two pairs of infrared beam breakers, and 1 camera that records video by motion detection) mounted around the entrance of a nest container. This function can also integrate clusters of detections with perching events identified by the function `find_rfid_perching_events` (e.g. when an individual was perched in the entrance of the nest container).
#' 
#' @return A spreadsheet in .csv format with the metadata columns from the original pre-processed data used as input (including individual identity information from RFID data), columns indicating the start and end time of each detection cluster, all the possible edges or transitions detected in the sequence of sensor events, and the inferred directionality of sensor events. Each row in the .csv file is detection cluster identified by the function. Information about the date of integration is also contained in the resulting spreadsheet.
#' 

score_detectionClusters <- function(file_nm, sensor_id_col, timestamps_col, PIT_tag_col, rfid_label, camera_label, outer_irbb_label, inner_irbb_label, general_metadata_cols, video_metadata_cols, integrate_perching, path, data_dir, out_dir, out_file_nm = "scored_detectionClusters.csv", tz, POSIXct_format = "%Y-%m-%d %H:%M:%OS"){
  
  # Get the current global options
  orig_opts <- options()
  
  # Set the number of digits for visualization. Under the hood there is full precision, but this helps for visual confirmation of decimal seconds
  options("digits.secs" = 6)
  
  # Get the user-specified values for each formal argument of the current function
  f_args <- getFunctionParameters()
  
  # Check that the formal arguments were all specified, and are not NULL or NA
  invisible(sapply(1:length(f_args), function(i){
    check_defined(f_args[i])
  }))
  
  # Check that the formal arguments that should be strings are strings
  expect_bool <- c("integrate_perching")
  
  expect_strings <- f_args[-grep(paste(paste("^", c(expect_bool), "$", sep = ""), collapse = "|"), names(f_args))]
  
  invisible(sapply(1:length(expect_strings), function(i){
    check_string(expect_strings[[i]])
  }))
  
  # Check that the formal arguments that should be Boolean are Boolean
  invisible(sapply(1:length(expect_bool), function(i){
    check_boolean(f_args[[grep(paste(paste("^", expect_bool[i], "$", sep = ""), collapse = "|"), names(f_args))]])
  }))
  
  # Check that the input directory exists
  check_dirs(path, data_dir)
  
  # Check that the input file exists in the input directory
  check_file(file.path(path, data_dir, file_nm))
  
  # Create the directory for saving the output file if it doesn't already exist
  if(!dir.exists(file.path(path, out_dir))){
    dir.create(file.path(path, out_dir))
  }
  
  detectns <- read.csv(file.path(path, data_dir, file_nm)) %>% 
    # Make sure that the timestamps are in the right format
    dplyr::mutate(
      start = as.POSIXct(format(as.POSIXct(start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
      end = as.POSIXct(format(as.POSIXct(end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
    ) %>% 
    rowid_to_column()
  
  # Check that this objects is a data frame
  check_df_class(detectns)
  
  # Check that the expected columns from formal arguments are found in each data frame
  colnames_fArgs <- f_args[grep("col", names(f_args))][-grep("general_metadata_cols", names(f_args[grep("col", names(f_args))]))]
  
  invisible(sapply(1:length(colnames_fArgs), function(i){
    check_fArgs_data_cols(colnames_fArgs[[i]], detectns)
  }))
  
  # Check that the expected columns from formal arguments do not have NAs
  colnames_fArgs2 <- colnames_fArgs[-grep("PIT_tag", names(colnames_fArgs))]
  
  invisible(sapply(1:length(colnames_fArgs2), function(i){
    check_fArgs_cols_nas(colnames_fArgs2[[i]], detectns)
  }))
  
  # Check that date-related columns are found in the data
  expected_cols <- c("year", "month", "day")
  
  invisible(sapply(1:length(expected_cols), function(i){
    check_data_cols(expected_cols[i], detectns)
  }))
  
  # Check that the date-related columns do not have NAs
  invisible(sapply(1:length(expected_cols), function(i){
    check_cols_nas(expected_cols[i], detectns)
  }))
  
  # Check that columns with timestamps are in the right format
  check_tstmps_cols("timestamps_col", detectns, "%Y-%m-%d %H:%M:%OS6")
  
  # Find all of the edges that occur in each sequence of sensor triggering events
  detectns_edges <- detectns %>%
    group_by(rowid) %>% 
    nest() %>% 
    # Make a data frame of the indices of edges in the sensor type sequences
    dplyr::mutate(
      # Each nested data frame represents a different cluster of detections
      edges = map(
        .x = data,
        # Get the edges for each burst of detections
        # TKTK in testing, need to check that the correct number of columns are returned even when edges very in length across bouts
        .f = ~ dplyr::select(.x, start, end, event_seq) %>% 
          pmap_dfr(., function(start, end, event_seq){
            
            sensor_events <- strsplit(event_seq, split = "; ")[[1]]
            
            li <- cumsum(rle(sensor_events)[["lengths"]])
            
            # Get edges using dyads of the last indices
            edges <- unlist(lapply(1:length(li), function(i){
              if(i < length(li)){
                return(paste(sensor_events[li[i]], sensor_events[li[i + 1]], sep = " - "))
              } else if(i == 1 & length(li) == 1){
                return(NA)
              }
            }))
            
            # Use the first edge to label directionality
            if(!is.na(edges[1])){
              
              if(grepl(rfid_label, edges[1]) & grepl(camera_label, edges[1])){
                
                if(edges[1] == paste(rfid_label, camera_label, sep = " - ")){
                  rfid_camera_direction <- "entrance"
                } else if(edges[1] == paste(camera_label, rfid_label, sep = " - ")){
                  rfid_camera_direction <- "exit"
                }
                
                rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- outer_irbb_camera_direction <- inner_irbb_camera_direction <- outer_inner_irbb_direction <- NA
                
              } else if(grepl(rfid_label, edges[1]) & grepl(paste(c(outer_irbb_label, inner_irbb_label), collapse = "|"), edges[1])){
                
                if(edges[1] == paste(outer_irbb_label, rfid_label, sep = " - ")){
                  rfid_outer_irbb_direction <- "entrance"
                  rfid_inner_irbb_direction <- NA
                } else if(edges[1] == paste(rfid_label, outer_irbb_label, sep = " - ")){
                  rfid_outer_irbb_direction <- "exit"
                  rfid_inner_irbb_direction <- NA
                } else if(edges[1] == paste(rfid_label, inner_irbb_label, sep = " - ")){
                  rfid_inner_irbb_direction <- "entrance"
                  rfid_outer_irbb_direction <- NA
                } else if(edges[1] == paste(inner_irbb_label, rfid_label, sep = " - ")){
                  rfid_inner_irbb_direction <- "exit"
                  rfid_outer_irbb_direction <- NA
                }
                
                rfid_camera_direction <- outer_irbb_camera_direction <- inner_irbb_camera_direction <- outer_inner_irbb_direction <- NA
                
              } else if(grepl(camera_label, edges[1]) & grepl(paste(c(outer_irbb_label, inner_irbb_label), collapse = "|"), edges[1])){
                
                if(edges[1] == paste(outer_irbb_label, camera_label, sep = " - ")){
                  outer_irbb_camera_direction <- "entrance"
                  inner_irbb_camera_direction <- NA
                } else if(edges[1] == paste(camera_label, outer_irbb_label, sep = " - ")){
                  outer_irbb_camera_direction <- "exit"
                  inner_irbb_camera_direction <- NA
                } else if(edges[1] == paste(inner_irbb_label, camera_label, sep = " - ")){
                  inner_irbb_camera_direction <- "entrance"
                  outer_irbb_camera_direction <- NA
                } else if(edges[1] == paste(camera_label, inner_irbb_label, sep = " - ")){
                  inner_irbb_camera_direction <- "exit"
                  outer_irbb_camera_direction <- NA
                }
                
                rfid_camera_direction <- rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- outer_inner_irbb_direction <- NA
                
              } else if(!grepl("Camera|RFID", edges[1]) & grepl(paste(c(outer_irbb_label, inner_irbb_label), collapse = "|"), edges[1])){
                
                if(edges[1] == paste(outer_irbb_label, inner_irbb_label, sep = " - ")){
                  outer_inner_irbb_direction <- "entrance"
                } else if(edges[1] == paste(inner_irbb_label, outer_irbb_label, sep = " - ")){
                  outer_inner_irbb_direction <- "exit"
                }
                
                rfid_camera_direction <- rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- inner_irbb_camera_direction <- outer_irbb_camera_direction <- NA
                
              }
              
            } else {
              
              rfid_camera_direction <- rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- outer_irbb_camera_direction <- inner_irbb_camera_direction <- outer_inner_irbb_direction <- NA
              
            }
            
            # Get edges using dyads of the last indices
            edges <- data.frame(t(matrix(edges)))
            
            names(edges) <- paste("Edge", seq(1, length(edges), 1), sep = "_")
            
            # Add the unique sensor labels that were present in each bout
            sensor_ids <- paste(unique(sensor_events), collapse = "; ")
            
            tmp <- data.frame(
              start = start,
              end = end,
              sensor_ids = sensor_ids
            ) %>% 
              bind_cols(
                edges
              ) %>% 
              dplyr::mutate(
                rfid_camera_direction = rfid_camera_direction,
                rfid_outer_irbb_direction = rfid_outer_irbb_direction,
                rfid_inner_irbb_direction = rfid_inner_irbb_direction,
                outer_irbb_camera_direction = outer_irbb_camera_direction,
                inner_irbb_camera_direction = inner_irbb_camera_direction,
                outer_inner_irbb_direction = outer_inner_irbb_direction
              )
            
            return(tmp)
            
          })
      ) 
    ) %>%
    dplyr::select(-c(data)) %>% 
    unnest(`cols` = c(edges)) %>%
    ungroup()
  
  # If only RFID data is present, then add back metadata about individual identities from the integration
  if(any(grepl(rfid_label, detectns$event_seq)) & !any(grepl(camera_label, detectns$event_seq))){
    
    detectns_edges2 <- detectns_edges %>% 
      dplyr::inner_join(
        detectns %>% 
          dplyr::select("rowid", names(.)[grep("indiv", names(.))]),
        by = "rowid"
      ) %>% 
      dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))], names(.)[grep("indiv", names(.))])
    
  } 
  
  # If only Camera data is present, then add back metadata about videos from the integration
  if(any(grepl(camera_label, detectns$event_seq)) & !any(grepl(rfid_label, detectns$event_seq))){
    
    detectns_edges2 <- detectns_edges %>% 
      dplyr::inner_join(
        detectns %>% 
          dplyr::select("rowid", names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))]),
        by = "rowid"
      ) %>% 
      dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))], names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))])
    
  }
  
  # If RFID and Camera data is present, then add back individual identity and video metadata
  if(any(grepl(rfid_label, detectns$event_seq)) & any(grepl(camera_label, detectns$event_seq))){
    
    detectns_edges2 <- detectns_edges %>% 
      dplyr::inner_join(
        detectns %>% 
          dplyr::select("rowid", names(.)[grep("indiv", names(.))], names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))]),
        by = "rowid"
      ) %>% 
      dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))], names(.)[grep("indiv", names(.))], names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))])
    
  } 
  
  if(!any(grepl(paste(c(rfid_label, camera_label), collapse = "|"), detectns$event_seq))){
    
    detectns_edges2 <- detectns_edges %>% 
      dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))])
    
  }

  # Integrate perching events if specified
  if(integrate_perching){
    
    perch_df <- read.csv(file.path(path, data_dir, "perching_events.csv"))  %>% 
      # Make sure that the timestamps are in the right format
      dplyr::mutate(
        perching_start = as.POSIXct(format(as.POSIXct(perching_start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
        perching_end = as.POSIXct(format(as.POSIXct(perching_end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
      )
    
    if(nrow(perch_df) > 0){
      
      # For each burst or bout of activity, figure out whether it occurred during a perching event and add that perching event to the final dataset
      tmp_df <- detectns_edges2 %>% 
        dplyr::select(rowid, start, end) %>% 
        pmap_dfr(., function(rowid, start, end){
          
          tmp_perching <- perch_df %>% 
            dplyr::filter(
              start >= perching_start & end <= perching_end 
            ) %>% 
            dplyr::rename(
              perching_PIT_tag = !!sym(PIT_tag_col)
            ) %>% 
            dplyr::mutate(
              de_rowid = rowid
            ) %>% 
            dplyr::select(de_rowid, perching_PIT_tag, perching_start, perching_end, perching_duration_s, unique_perching_event)
          
          return(tmp_perching)
          
        })

      # Then add the perching event assignment for the given bout as new columns
      detectns_edges_p <- detectns_edges2 %>% 
        dplyr::left_join(
          tmp_df,
          by = c("rowid" = "de_rowid")
        )
      
    } else {
      
      warning("The perching events dataset was empty; skipping integration of perching events")
      detectns_edges_p <- detectns_edges2
      
    }
    
  } else {
    
    detectns_edges_p <- detectns_edges2
    
  }
  
  detectns_edges_p <- detectns_edges_p %>% 
    dplyr::mutate(
      data_stage = "integrated",
      date_processed = paste(Sys.Date(), Sys.time(), sep = " ")
    ) %>% 
    dplyr::select(-c("rowid"))
  
  write.csv(detectns_edges_p, file.path(path, out_dir, out_file_nm), row.names = FALSE)
  
  # Reset the current global options
  options(orig_opts) 
  
}