#' @title score_detectionClusters
#' @description Score clusters of detections to infer directionality
#' 
#' @param file_nm A character vector of length 1. This argument should be the name and extension of one .csv file that contains clusters detected using the function `find_detectionClusters`. For instance, c("detection_clusters.csv"). In this spreadsheet, each row should be a unique cluster of detections. The spreadsheet must contain all the columns specified in the subsequent arguments.
#' @param sensor_id_col A character string. This argument is the name of the metadata column in the perching event data to be integrated that contains information about the data type (e.g. "sensor_id"). The default is NULL, since integrating perching data is not a requirement.
#' @param PIT_tag_col A character string. This argument is the name of the metadata column in the perching event data to be integrated that contains information about the PIT tags detected by the RFID antenna (e.g. "PIT_tag_ID"). The default is NULL, since integrating perching data is not a requirement.
#' @param rfid_label A character string. This argument is the label for the RFID sensor in the sensor_id_col column in pre-processed data (e.g. "RFID"). Set this argument to NULL if RFID data is not present in the input dataset.
#' @param camera_label A character string. This argument is the label for the camera sensor that records video in the sensor_id_col column in pre-processed data (e.g. "Camera"). Set this argument to NULL if video data is not present in the input dataset.
#' @param outer_irbb_label A character string. This argument is the label for the outer pair of beam breakers in the sensor_id_col column in pre-processed data (e.g. "Outer Beam Breaker"). Set this argument to NULL if outer beam breaker data is not present in the input dataset.
#' @param inner_irbb_label A character string. This argument is the label for the inner pair of beam breakers in the sensor_id_col column in pre-processed data (e.g. "Inner Beam Breaker"). Set this argument to NULL if inner beam breaker data is not present in the input dataset.
#' @param general_metadata_cols A character vector. This argument should be a string of the general metadata column names that will be carried through into the spreadsheet generated by this function. For instance: c("chamber_id", "year", "month", "day"). These columns will be added as the first columns in the integrated data frame, in the same order in which they are provided.
#' @param video_metadata_cols A character vector. This argument should be a string of the video metadata column names that will be carried through into the resulting data frame representing the integrated data. For instance: c("total_pixels_motionTrigger", "pixel_threshold", "video_file_name"). These columns will be added as later columns in resulting data frame, in the same order in which they were specified.
#' @param integrate_perching Boolean. If TRUE, then the perching events identified using `find_perching_events` with either RFID or beam breaker data will be integrated with this dataset. This integration is done by finding detection clusters that occurred within the duration of a perching event. If FALSE, then perching events will not be integrated. 
#' @param perching_dataset A character string. Use "RFID", "IRBB", or "RFID-IRBB" to specify which dataset of perching events to integrate. Specifying "RFID-IRBB" means that perching events detected using both sensor types will be integrated, resulting in triple the number of columns for perching event data in the resulting spreadsheet (RFID, outer beam breaker pair, inner beam breaker pair). The default is NULL.
#' @param perching_prefix A character string. The prefix for the file name of the perching events spreadsheet. This character string needs to contain all of the symbols in the file name up until the sensor label and extension (e.g. "perching_events_"). The default is NULL.
#' @param path A character string. This argument should be the path on the local computer or external hard drive specifying where the data is saved across sensors for a given experimental setup. For instance, "/media/gsvidaurre/Anodorhynchus/Data_Testing/Box_02_31Dec2022/Data".
#' @param data_dir A character string. This argument should be the name of the directory where the pre-processed data that is used as input is saved inside the path above. For instance, "processed".
#' @param out_dir A character string. This argument should be the name of a directory specifying where the .csv file of integrated data should be saved. For instance, "integrated". This folder will be appended to the data_path and created as a new directory if it doesn't already exist.
#' @param out_file_nm A character string. The name (plus extension) of the resulting file that will be written to out_dir. The default is "scored_detectionClusters.csv"
#' @param tz A character string. This argument should contain the timezone used for converting timestamps to POSIXct format. For instance, "America/New York". See the base function `as.POSIXct` for more information.
#' @param POSIXct_format A character string. This argument should contain the format used to converting timestamps to POSIXct format. The default is "%Y-%m-%d %H:%M:%OS6" to return timestamps with milliseconds in decimal format. See the base function `as.POSIXct` for more information.
#' 
#' @details `score_detectionClusters` uses the order in which sensors triggered within clusters of detections identified by `find_detectionCusters`. The function finds edges or transitions between sensor labels in the sequence of detections for each cluster detected. Then, the function uses the order of the sensor labels in the first edge to label the directionality of movement events. `score_detectionClusters` was written for a hardware setup with multiple movement sensors (1 RFID antenna, two pairs of infrared beam breakers, and 1 camera that records video by motion detection) mounted around the entrance of a nest container (see the README for more information). This function can also integrate clusters of detections with perching events identified by the function `find_perching_events` (e.g. when an individual was perched in the entrance of the nest container).
#' 
#' @return A spreadsheet in .csv format with the metadata columns from the original pre-processed data used as input (including individual identity information from RFID data), columns indicating the start and end time of each detection cluster, all the possible edges or transitions detected in the sequence of sensor events, and the inferred directionality of sensor events. Each row in the .csv file is detection cluster identified by the function. Information about the date of integration is also contained in the resulting spreadsheet.
#' 
#' 

# file_nm = "simulated_detectionClusters.csv"
# sensor_id_col = NULL
# PIT_tag_col = NULL
# rfid_label = "RFID"
# camera_label = NULL
# outer_irbb_label = "Outer Beam Breaker"
# inner_irbb_label = "Inner Beam Breaker"
# general_metadata_cols = c("chamber_id", "year", "month", "day")
# video_metadata_cols = NULL
# integrate_perching = FALSE
# perching_dataset = NULL
# perching_prefix = NULL
# path = path
# data_dir = data_dir
# out_dir = data_dir
# out_file_nm = "scored_detectionClusters.csv"
# tz = "America/New York"
# POSIXct_format = "%Y-%m-%d %H:%M:%OS"


score_detectionClusters <- function(file_nm, sensor_id_col = NULL, PIT_tag_col = NULL, rfid_label, camera_label, outer_irbb_label, inner_irbb_label, general_metadata_cols, video_metadata_cols, integrate_perching, perching_dataset = NULL, perching_prefix = NULL, path, data_dir, out_dir, out_file_nm = "scored_detectionClusters.csv", tz, POSIXct_format = "%Y-%m-%d %H:%M:%OS"){
  
  # Get the current global options
  orig_opts <- options()
  
  # Set the number of digits for visualization. Under the hood there is full precision, but this helps for visual confirmation of decimal seconds
  options("digits.secs" = 6)
  
  # Get the user-specified values for each formal argument of the current function
  f_args <- getFunctionParameters()
  
  # Check that the formal arguments were all specified, and are not NULL or NA
  invisible(sapply(1:length(f_args), function(i){
    check_defined(f_args[i])
  }))
  
  # Check that the formal arguments that should be strings are strings
  expect_bool <- c("integrate_perching")
  
  # Check that the formal arguments that should be NULL are NULL
  if(integrate_perching){
    
    expect_null <- ""
    
  } else if(!integrate_perching){
    
    expect_null <- c("perching_dataset", "perching_prefix")
    
    invisible(sapply(1:length(expect_null), function(i){
      check_null(f_args[[grep(paste(paste("^", expect_null[i], "$", sep = ""), collapse = "|"), names(f_args))]])
    }))
    
  }
  
  # Get all the NULL arguments (e.g. camera_label or sensor_id_col may be NULL)
  wh_null <- which(unlist(sapply(1:length(f_args), function(i){
    is.null(f_args[[i]])
  })))
  
  if(length(wh_null) == 0){
    
    expect_strings <- f_args[-grep(paste(paste("^", c(expect_bool, expect_null), "$", sep = ""), collapse = "|"), names(f_args))]
    
  } else {
    
    expect_strings <- f_args[-grep(paste(paste("^", c(expect_bool, names(f_args)[wh_null]), "$", sep = ""), collapse = "|"), names(f_args))]
    
  }
  
  invisible(sapply(1:length(expect_strings), function(i){
    check_string(expect_strings[[i]])
  }))
  
  # Check that the formal arguments that should be Boolean are Boolean
  invisible(sapply(1:length(expect_bool), function(i){
    check_boolean(f_args[[grep(paste(paste("^", expect_bool[i], "$", sep = ""), collapse = "|"), names(f_args))]])
  }))
  
  # Check that the input directory exists
  check_dirs(path, data_dir)
  
  # Check that the input file exists in the input directory
  check_file(file.path(path, data_dir), file_nm)
  
  # Check that the perching file(s) also exist in the input directory
  if(integrate_perching){
    
    check_file(file.path(path, data_dir), paste(perching_prefix, perching_dataset, ".csv", sep = ""))
    
  }
  
  # Create the directory for saving the output file if it doesn't already exist
  if(!dir.exists(file.path(path, out_dir))){
    dir.create(file.path(path, out_dir))
  }
  
  detectns <- read.csv(file.path(path, data_dir, file_nm)) %>% 
    # Make sure that the timestamps are in the right format
    dplyr::mutate(
      start = as.POSIXct(format(as.POSIXct(start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
      end = as.POSIXct(format(as.POSIXct(end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
    ) %>% 
    rowid_to_column()
  
  # Check that this objects is a data frame
  check_df_class(detectns)
  
  # Check that the expected columns from formal arguments are found in each data frame
  if(!is.null(rfid_label)){
    
    colnames_fArgs <- f_args[grep("col", names(f_args))][-grep("general_metadata_cols", names(f_args[grep("col", names(f_args))]))]
    
    # Do not include the RFID related columns in the tests below of columns in the main input data
  } else if(is.null(rfid_label) & integrate_perching){
    
    colnames_fArgs <- f_args[grep("col", names(f_args))][-grep("general_metadata_cols|sensor_id_col|PIT_tag_col", names(f_args[grep("col", names(f_args))]))]
    
  }
  
  if(length(colnames_fArgs) > 0){
    
    invisible(sapply(1:length(colnames_fArgs), function(i){
      check_fArgs_data_cols(colnames_fArgs[[i]], detectns)
    }))
    
    # Check that the expected columns from formal arguments do not have NAs
    colnames_fArgs2 <- colnames_fArgs[-grep("PIT_tag", names(colnames_fArgs))]
    
    if(length(colnames_fArgs2) > 0){
      
      invisible(sapply(1:length(colnames_fArgs2), function(i){
        check_fArgs_cols_nas(colnames_fArgs2[[i]], detectns)
      }))
      
    }
    
  }
  
  # Check that date-related columns are found in the data
  expected_cols <- c("year", "month", "day")
  
  invisible(sapply(1:length(expected_cols), function(i){
    check_data_cols(expected_cols[i], detectns)
  }))
  
  # Check that the date-related columns do not have NAs
  invisible(sapply(1:length(expected_cols), function(i){
    check_cols_nas(expected_cols[i], detectns)
  }))
  
  # Check that columns with timestamps are in the right format
  check_tstmps_cols("start", detectns, "%Y-%m-%d %H:%M:%OS6")
  check_tstmps_cols("end", detectns, "%Y-%m-%d %H:%M:%OS6")
  
  # Find all of the edges that occur in each sequence of sensor triggering events
  detectns_edges <- detectns %>%
    group_by(rowid) %>% 
    nest() %>% 
    # Make a data frame of the indices of edges in the sensor type sequences
    dplyr::mutate(
      # Each nested data frame represents a different cluster of detections
      edges = map(
        .x = data,
        # Get the edges for each burst of detections
        # TKTK in testing, need to check that the correct number of columns are returned even when edges very in length across bouts
        .f = ~ dplyr::select(.x, start, end, event_seq) %>% 
          pmap_dfr(., function(start, end, event_seq){
            
            sensor_events <- strsplit(event_seq, split = "; ")[[1]]
            
            li <- cumsum(rle(sensor_events)[["lengths"]])
            
            # Get edges using dyads of the last indices
            edges <- unlist(lapply(1:length(li), function(i){
              if(i < length(li)){
                return(paste(sensor_events[li[i]], sensor_events[li[i + 1]], sep = " - "))
              } else if(i == 1 & length(li) == 1){
                return(NA)
              }
            }))
            
            # Use the first edge to label directionality
            if(!is.na(edges[1])){
              
              if(!is.null(rfid_label)){
                
                if(!is.null(camera_label)){
                  
                  if(grepl(rfid_label, edges[1]) & grepl(camera_label, edges[1])){
                    
                    if(edges[1] == paste(rfid_label, camera_label, sep = " - ")){
                      rfid_camera_direction <- "entrance"
                    } else if(edges[1] == paste(camera_label, rfid_label, sep = " - ")){
                      rfid_camera_direction <- "exit"
                    }
                    
                    rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- outer_irbb_camera_direction <- inner_irbb_camera_direction <- outer_inner_irbb_direction <- NA
                    
                  } 
                  
                }
                
              }
              
              if(!is.null(rfid_label)){
                
                if(grepl(rfid_label, edges[1]) & grepl(paste(c(outer_irbb_label, inner_irbb_label), collapse = "|"), edges[1])){
                  
                  if(edges[1] == paste(outer_irbb_label, rfid_label, sep = " - ")){
                    rfid_outer_irbb_direction <- "entrance"
                    rfid_inner_irbb_direction <- NA
                  } else if(edges[1] == paste(rfid_label, outer_irbb_label, sep = " - ")){
                    rfid_outer_irbb_direction <- "exit"
                    rfid_inner_irbb_direction <- NA
                  } else if(edges[1] == paste(rfid_label, inner_irbb_label, sep = " - ")){
                    rfid_inner_irbb_direction <- "entrance"
                    rfid_outer_irbb_direction <- NA
                  } else if(edges[1] == paste(inner_irbb_label, rfid_label, sep = " - ")){
                    rfid_inner_irbb_direction <- "exit"
                    rfid_outer_irbb_direction <- NA
                  }
                  
                  rfid_camera_direction <- outer_irbb_camera_direction <- inner_irbb_camera_direction <- outer_inner_irbb_direction <- NA
                  
                }
                
              }
              
              if(!is.null(camera_label)){
                
                if(grepl(camera_label, edges[1]) & grepl(paste(c(outer_irbb_label, inner_irbb_label), collapse = "|"), edges[1])){
                  
                  if(edges[1] == paste(outer_irbb_label, camera_label, sep = " - ")){
                    outer_irbb_camera_direction <- "entrance"
                    inner_irbb_camera_direction <- NA
                  } else if(edges[1] == paste(camera_label, outer_irbb_label, sep = " - ")){
                    outer_irbb_camera_direction <- "exit"
                    inner_irbb_camera_direction <- NA
                  } else if(edges[1] == paste(inner_irbb_label, camera_label, sep = " - ")){
                    inner_irbb_camera_direction <- "entrance"
                    outer_irbb_camera_direction <- NA
                  } else if(edges[1] == paste(camera_label, inner_irbb_label, sep = " - ")){
                    inner_irbb_camera_direction <- "exit"
                    outer_irbb_camera_direction <- NA
                  }
                  
                  rfid_camera_direction <- rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- outer_inner_irbb_direction <- NA
                  
                } 
                
              }
              
              if(is.null(rfid_label) & is.null(camera_label)){
                
                if(!grepl("Camera|RFID", edges[1]) & grepl(paste(c(outer_irbb_label, inner_irbb_label), collapse = "|"), edges[1])){
                  
                  if(edges[1] == paste(outer_irbb_label, inner_irbb_label, sep = " - ")){
                    outer_inner_irbb_direction <- "entrance"
                  } else if(edges[1] == paste(inner_irbb_label, outer_irbb_label, sep = " - ")){
                    outer_inner_irbb_direction <- "exit"
                  }
                  
                  rfid_camera_direction <- rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- inner_irbb_camera_direction <- outer_irbb_camera_direction <- NA
                  
                }
                
              }
              
            } else {
              
              rfid_camera_direction <- rfid_outer_irbb_direction <- rfid_inner_irbb_direction <- outer_irbb_camera_direction <- inner_irbb_camera_direction <- outer_inner_irbb_direction <- NA
              
            }
            
            # Get edges using dyads of the last indices
            edges <- data.frame(t(matrix(edges)))
            
            names(edges) <- paste("Edge", seq(1, length(edges), 1), sep = "_")
            
            # Add the unique sensor labels that were present in each bout
            sensor_ids <- paste(unique(sensor_events), collapse = "; ")
            
            tmp <- data.frame(
              start = start,
              end = end,
              sensor_ids = sensor_ids
            ) %>% 
              bind_cols(
                edges
              ) %>% 
              dplyr::mutate(
                rfid_camera_direction = rfid_camera_direction,
                rfid_outer_irbb_direction = rfid_outer_irbb_direction,
                rfid_inner_irbb_direction = rfid_inner_irbb_direction,
                outer_irbb_camera_direction = outer_irbb_camera_direction,
                inner_irbb_camera_direction = inner_irbb_camera_direction,
                outer_inner_irbb_direction = outer_inner_irbb_direction
              )
            
            return(tmp)
            
          })
      ) 
    ) %>%
    dplyr::select(-c(data)) %>% 
    unnest(`cols` = c(edges)) %>%
    ungroup()
  
  # If only RFID data is present, then add back metadata about individual identities from the integration
  if(!is.null(rfid_label)){
    
    if(any(grepl(rfid_label, detectns$event_seq)) & is.null(camera_label)){
      
      detectns_edges2 <- detectns_edges %>% 
        dplyr::inner_join(
          detectns %>% 
            dplyr::select("rowid", names(.)[grep("indiv", names(.))]),
          by = "rowid"
        ) %>% 
        dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))], names(.)[grep("indiv", names(.))])
      
    } else {
      
      detectns_edges2 <- detectns_edges %>% 
        dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))])
      
    }
    
  }
  
  # If only Camera data is present, then add back metadata about videos from the integration
  if(!is.null(camera_label)){
    
    if(any(grepl(camera_label, detectns$event_seq)) & is.null(rfid_label)){
      
      detectns_edges2 <- detectns_edges %>% 
        dplyr::inner_join(
          detectns %>% 
            dplyr::select("rowid", names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))]),
          by = "rowid"
        ) %>% 
        dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))], names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))])
      
    } else {
      
      detectns_edges2 <- detectns_edges %>% 
        dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))])
      
    }
    
  }
  
  # If RFID and Camera data is present, then add back individual identity and video metadata
  if(!is.null(rfid_label) & !is.null(camera_label)){
    
    if(any(grepl(rfid_label, detectns$event_seq)) & any(grepl(camera_label, detectns$event_seq))){
      
      detectns_edges2 <- detectns_edges %>% 
        dplyr::inner_join(
          detectns %>% 
            dplyr::select("rowid", names(.)[grep("indiv", names(.))], names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))]),
          by = "rowid"
        ) %>% 
        dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))], names(.)[grep("indiv", names(.))], names(.)[grep(paste(video_metadata_cols, collapse = "|"), names(.))])
      
    } else {
      
      detectns_edges2 <- detectns_edges %>% 
        dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))])
      
    }
    
  }
  
  # If only beam breaker data is present, then return the current columns in order
  if(is.null(rfid_label) & is.null(camera_label)){
    
    detectns_edges2 <- detectns_edges %>% 
      dplyr::select(rowid, start, end, sensor_ids, names(.)[grep("Edge", names(.))], names(.)[grep("direction", names(.))])
    
  }
  
  # Integrate perching events if specified
  if(integrate_perching){
    
    # Read in perching event data depending on which datasets were specified
    if(perching_dataset != "RFID-IRBB"){
      
      perch_df <- read.csv(file.path(path, data_dir, paste(perching_prefix, perching_dataset, ".csv", sep = "")))  %>% 
        # Make sure that the timestamps are in the right format
        dplyr::mutate(
          perching_start = as.POSIXct(format(as.POSIXct(perching_start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
          perching_end = as.POSIXct(format(as.POSIXct(perching_end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
        )
      
    } else if(perching_dataset == "RFID-IRBB"){
      
      tmp_file_nms <- c(paste(perching_prefix, strsplit(perching_dataset, split = "-")[[1]][1], ".csv", sep = ""), paste(perching_prefix, strsplit(perching_dataset, split = "-")[[1]][2], ".csv", sep = ""))
      
      perch_df <- data.table::rbindlist(lapply(1:length(tmp_file_nms), function(i){
        tmp <- read.csv(file.path(path, data_dir, tmp_file_nms[i]))  %>% 
          # Make sure that the timestamps are in the right format
          dplyr::mutate(
            perching_start = as.POSIXct(format(as.POSIXct(perching_start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
            perching_end = as.POSIXct(format(as.POSIXct(perching_end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
          )
        
        # Add a PIT tag column with NAs for the beam breaker data 
      }), fill = TRUE)
      
    }
    
    if(nrow(perch_df) > 0){
      
      # For each detection cluster, figure out whether it occurred during a perching event and add that perching event to the final dataset
      
      if(perching_dataset %in% c("RFID", "RFID-IRBB")){
        
        tmp_df <- detectns_edges2 %>% 
          dplyr::select(rowid, start, end) %>% 
          pmap_dfr(., function(rowid, start, end){
            
            tmp_perching <- perch_df %>% 
              dplyr::filter(
                start >= perching_start & end <= perching_end 
              ) %>% 
              dplyr::rename(
                perching_PIT_tag = !!sym(PIT_tag_col)
              ) %>% 
              dplyr::mutate(
                de_rowid = rowid
              ) %>% 
              dplyr::select(de_rowid, all_of(sensor_id_col), perching_PIT_tag, perching_start, perching_end, perching_duration_s)
            
            return(tmp_perching)
            
          })
        
      } else if(perching_dataset == "IRBB"){
        
        tmp_df <- detectns_edges2 %>% 
          dplyr::select(rowid, start, end) %>% 
          pmap_dfr(., function(rowid, start, end){
            
            tmp_perching <- perch_df %>% 
              dplyr::filter(
                start >= perching_start & end <= perching_end 
              ) %>% 
              dplyr::mutate(
                de_rowid = rowid
              ) %>% 
              dplyr::select(de_rowid, all_of(sensor_id_col), perching_start, perching_end, perching_duration_s)
            
            return(tmp_perching)
            
          })
        
        
      } 
      
      # Then add the perching event assignment for the given bout as new columns, depending on the perching datasets used as input
      if(perching_dataset %in% c("RFID", "IRBB")){
        
        detectns_edges_p <- detectns_edges2 %>% 
          dplyr::left_join(
            tmp_df %>% 
              dplyr::rename(
                perching_sensor = !!sym(sensor_id_col)
              ),
            by = c("rowid" = "de_rowid")
          )
        
        # If both RFID and IRBB were specified as perching datasets, then add back perching events from each dataset as separate columns
      } else if(perching_dataset == "RFID-IRBB"){
        
        detectns_edges_p <- detectns_edges2 %>% 
          dplyr::left_join(
            tmp_df %>% 
              dplyr::filter(!!sym(sensor_id_col) == "RFID") %>% 
              dplyr::rename(
                `perching_rfid_start` = "perching_start",
                `perching_rfid_end` = "perching_end",
                `perching_rfid_duration_s` = "perching_duration_s"
              ) %>% 
              dplyr::select(-c(all_of(sensor_id_col))),
            by = c("rowid" = "de_rowid")
          ) %>% 
          dplyr::left_join(
            tmp_df %>% 
              dplyr::filter(!!sym(sensor_id_col) == "Outer Beam Breaker") %>% 
              dplyr::rename(
                `perching_outer_irbb_start` = "perching_start",
                `perching_outer_irbb_end` = "perching_end",
                `perching_outer_irbb_duration_s` = "perching_duration_s"
              ) %>% 
              dplyr::select(-c(all_of(sensor_id_col), "perching_PIT_tag")),
            by = c("rowid" = "de_rowid")
          ) %>% 
          dplyr::left_join(
            tmp_df %>% 
              dplyr::filter(!!sym(sensor_id_col) == "Inner Beam Breaker") %>% 
              dplyr::rename(
                `perching_inner_irbb_start` = "perching_start",
                `perching_inner_irbb_end` = "perching_end",
                `perching_inner_irbb_duration_s` = "perching_duration_s"
              ) %>% 
              dplyr::select(-c(all_of(sensor_id_col), "perching_PIT_tag")),
            by = c("rowid" = "de_rowid")
          )
        
      }
      
    } else {
      
      warning("The perching events dataset was empty; skipping integration of perching events")
      detectns_edges_p <- detectns_edges2
      
    }
    
  } else {
    
    detectns_edges_p <- detectns_edges2
    
  }
  
  detectns_edges_p <- detectns_edges_p %>% 
    dplyr::mutate(
      data_stage = "integrated",
      date_processed = paste(Sys.Date(), Sys.time(), sep = " ")
    ) %>% 
    dplyr::select(-c("rowid"))
  
  
  
  write.csv(detectns_edges_p, file.path(path, out_dir, out_file_nm), row.names = FALSE)
  
  # Reset the current global options
  options(orig_opts) 
  
}