#     .x = runs_lead_tag1,
#     # Need to rename columns in order to apply the generalized function inside pmap_dfr
#     .y = data %>%
#       dplyr::rename(
#         `tag1_ts` = "leading_ts",
#         `tag2_ts` = !!sym(rfid_cols[2])
#       ),
#     .f = ~ dplyr::filter(.x,
#                          vals & rl >= run_length
#     ) %>%
#       dplyr::select(fi, li, rl) %>%
#       pmap_dfr(find_syncs) %>%
#       dplyr::mutate(
#         first_PIT_tag = rfid_cols[1]
#       )
#   )
# ) %>%
# glimpse()
# glimpse(test_list$data[[1]])
# Lag differences, first PIT tag
dplyr::mutate(
tag_1_lag_syncs = map(
.x = runs_lag_tag1,
# Need to rename columns in order to apply the generalized function inside pmap_dfr
.y = data %>%
dplyr::rename(
`tag1_ts` = "lagging_ts",
`tag2_ts` = !!sym(rfid_cols[2])
),
.f = ~ dplyr::filter(.x,
vals & rl >= run_length
) %>%
dplyr::select(fi, li, rl) %>%
pmap_dfr(find_syncs)
#   dplyr::mutate(
#     first_PIT_tag = rfid_cols[1]
#   )
)
) %>%
glimpse()
# A function to feed to pmap_dfr to simplify the code below
find_syncs <- function(fi, li, rl, .y){
# If the run length is 1, then make sure the start and end indices are the both set as the last index
if(rl == 1){
ind_e <- ind_s <- li
} else {
ind_s <- fi
ind_e <- li
}
tmp_df <- data.frame(
# The start timestamps need to come from lagging_ts. For the 1st PIT tag to be detected first, there should have been a negative difference in timestamps
start = .y[[1]] %>%
slice(ind_s) %>%
pull(tag1_ts)
) %>%
# The end timestamps need to come from !!sym(rfid_cols[2]), since for the 1st PIT tag to be detected first, there should have been a negative difference in timestamps
dplyr::mutate(
end = .y[[1]] %>%
slice(ind_e) %>%
pull(tag2_ts),
total_detections = rl
)
return(tmp_df)
}
# Starting the mapping earlier
test_list <- lags_df %>%
dplyr::mutate(
group_col = 1
) %>%
group_by(group_col) %>%
nest() %>%
# Lead differences, first PIT tag
dplyr::mutate(
runs_lead_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag1)[["lengths"]]) - (rle(binary_lead_tag1)[["lengths"]]),
li = cumsum(rle(binary_lead_tag1)[["lengths"]]),
vals = rle(binary_lead_tag1)[["values"]],
rl = rle(binary_lead_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, first PIT tag
dplyr::mutate(
runs_lag_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag1)[["lengths"]]) - (rle(binary_lag_tag1)[["lengths"]]),
li = cumsum(rle(binary_lag_tag1)[["lengths"]]),
vals = rle(binary_lag_tag1)[["values"]],
rl = rle(binary_lag_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# glimpse()
# Lead differences, second PIT tag
dplyr::mutate(
runs_lead_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag2)[["lengths"]]) - (rle(binary_lead_tag2)[["lengths"]]),
li = cumsum(rle(binary_lead_tag2)[["lengths"]]),
vals = rle(binary_lead_tag2)[["values"]],
rl = rle(binary_lead_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, second PIT tag
dplyr::mutate(
runs_lag_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag2)[["lengths"]]) - (rle(binary_lag_tag2)[["lengths"]]),
li = cumsum(rle(binary_lag_tag2)[["lengths"]]),
vals = rle(binary_lag_tag2)[["values"]],
rl = rle(binary_lag_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
ungroup() %>%
# Then do mapping to get the actual synchronized events for each nested data frame of lead and lag runs per PIT tag
# # Lead differences, first PIT tag
# dplyr::mutate(
#   tag_1_lead_syncs = map(
#     .x = runs_lead_tag1,
#     # Need to rename columns in order to apply the generalized function inside pmap_dfr
#     .y = data %>%
#       dplyr::rename(
#         `tag1_ts` = "leading_ts",
#         `tag2_ts` = !!sym(rfid_cols[2])
#       ),
#     .f = ~ dplyr::filter(.x,
#                          vals & rl >= run_length
#     ) %>%
#       dplyr::select(fi, li, rl) %>%
#       pmap_dfr(find_syncs) %>%
#       dplyr::mutate(
#         first_PIT_tag = rfid_cols[1]
#       )
#   )
# ) %>%
# glimpse()
# glimpse(test_list$data[[1]])
# Lag differences, first PIT tag
dplyr::mutate(
tag_1_lag_syncs = map(
.x = runs_lag_tag1,
# Need to rename columns in order to apply the generalized function inside pmap_dfr
.y = data %>%
dplyr::rename(
`tag1_ts` = "lagging_ts",
`tag2_ts` = !!sym(rfid_cols[2])
),
.f = ~ dplyr::filter(.x,
vals & rl >= run_length
) %>%
dplyr::select(fi, li, rl) %>%
pmap_dfr(find_syncs)
#   dplyr::mutate(
#     first_PIT_tag = rfid_cols[1]
#   )
)
) %>%
glimpse()
# A function to feed to pmap_dfr to simplify the code below
find_syncs <- function(fi, li, rl){
# If the run length is 1, then make sure the start and end indices are the both set as the last index
if(rl == 1){
ind_e <- ind_s <- li
} else {
ind_s <- fi
ind_e <- li
}
tmp_df <- data.frame(
# The start timestamps need to come from lagging_ts. For the 1st PIT tag to be detected first, there should have been a negative difference in timestamps
start = .y[[1]] %>%
slice(ind_s) %>%
pull(tag1_ts)
) %>%
# The end timestamps need to come from !!sym(rfid_cols[2]), since for the 1st PIT tag to be detected first, there should have been a negative difference in timestamps
dplyr::mutate(
end = .y[[1]] %>%
slice(ind_e) %>%
pull(tag2_ts),
total_detections = rl
)
return(tmp_df)
}
# Starting the mapping earlier
test_list <- lags_df %>%
dplyr::mutate(
group_col = 1
) %>%
group_by(group_col) %>%
nest() %>%
# Lead differences, first PIT tag
dplyr::mutate(
runs_lead_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag1)[["lengths"]]) - (rle(binary_lead_tag1)[["lengths"]]),
li = cumsum(rle(binary_lead_tag1)[["lengths"]]),
vals = rle(binary_lead_tag1)[["values"]],
rl = rle(binary_lead_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, first PIT tag
dplyr::mutate(
runs_lag_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag1)[["lengths"]]) - (rle(binary_lag_tag1)[["lengths"]]),
li = cumsum(rle(binary_lag_tag1)[["lengths"]]),
vals = rle(binary_lag_tag1)[["values"]],
rl = rle(binary_lag_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# glimpse()
# Lead differences, second PIT tag
dplyr::mutate(
runs_lead_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag2)[["lengths"]]) - (rle(binary_lead_tag2)[["lengths"]]),
li = cumsum(rle(binary_lead_tag2)[["lengths"]]),
vals = rle(binary_lead_tag2)[["values"]],
rl = rle(binary_lead_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, second PIT tag
dplyr::mutate(
runs_lag_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag2)[["lengths"]]) - (rle(binary_lag_tag2)[["lengths"]]),
li = cumsum(rle(binary_lag_tag2)[["lengths"]]),
vals = rle(binary_lag_tag2)[["values"]],
rl = rle(binary_lag_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
ungroup() %>%
# Then do mapping to get the actual synchronized events for each nested data frame of lead and lag runs per PIT tag
# Lead differences, first PIT tag
dplyr::mutate(
tag_1_lead_syncs = map(
.x = runs_lead_tag1,
# Need to rename columns in order to apply the generalized function inside pmap_dfr
.y = data %>%
dplyr::rename(
`tag1_ts` = "leading_ts",
`tag2_ts` = !!sym(rfid_cols[2])
),
.f = ~ dplyr::filter(.x,
vals & rl >= run_length
) %>%
dplyr::select(fi, li, rl) %>%
pmap_dfr(find_syncs) %>%
dplyr::mutate(
first_PIT_tag = rfid_cols[1]
)
)
) %>%
glimpse()
# Starting the mapping earlier
test_list <- lags_df %>%
dplyr::mutate(
group_col = 1
) %>%
group_by(group_col) %>%
nest() %>%
# Lead differences, first PIT tag
dplyr::mutate(
runs_lead_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag1)[["lengths"]]) - (rle(binary_lead_tag1)[["lengths"]]),
li = cumsum(rle(binary_lead_tag1)[["lengths"]]),
vals = rle(binary_lead_tag1)[["values"]],
rl = rle(binary_lead_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, first PIT tag
dplyr::mutate(
runs_lag_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag1)[["lengths"]]) - (rle(binary_lag_tag1)[["lengths"]]),
li = cumsum(rle(binary_lag_tag1)[["lengths"]]),
vals = rle(binary_lag_tag1)[["values"]],
rl = rle(binary_lag_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# glimpse()
# Lead differences, second PIT tag
dplyr::mutate(
runs_lead_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag2)[["lengths"]]) - (rle(binary_lead_tag2)[["lengths"]]),
li = cumsum(rle(binary_lead_tag2)[["lengths"]]),
vals = rle(binary_lead_tag2)[["values"]],
rl = rle(binary_lead_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, second PIT tag
dplyr::mutate(
runs_lag_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag2)[["lengths"]]) - (rle(binary_lag_tag2)[["lengths"]]),
li = cumsum(rle(binary_lag_tag2)[["lengths"]]),
vals = rle(binary_lag_tag2)[["values"]],
rl = rle(binary_lag_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
ungroup() %>%
# Then do mapping to get the actual synchronized events for each nested data frame of lead and lag runs per PIT tag
# Lead differences, first PIT tag
dplyr::mutate(
tag_1_lead_syncs = map(
.x = runs_lead_tag1,
# Need to rename columns in order to apply the generalized function inside pmap_dfr
.y = data %>%
dplyr::rename(
`tag1_ts` = "leading_ts",
`tag2_ts` = !!sym(rfid_cols[2])
),
.f = ~ dplyr::filter(.x,
vals & rl >= run_length
) %>%
dplyr::select(fi, li, rl) %>%
pmap_dfr(find_syncs) %>%
dplyr::mutate(
first_PIT_tag = rfid_cols[1]
)
)
) %>%
# glimpse()
# glimpse(test_list$data[[1]])
# Lag differences, first PIT tag
dplyr::mutate(
tag_1_lag_syncs = map(
.x = runs_lag_tag1,
# Need to rename columns in order to apply the generalized function inside pmap_dfr
.y = data %>%
dplyr::rename(
`tag1_ts` = "lagging_ts",
`tag2_ts` = !!sym(rfid_cols[2])
),
.f = ~ dplyr::filter(.x,
vals & rl >= run_length
) %>%
dplyr::select(fi, li, rl) %>%
pmap_dfr(find_syncs)
#   dplyr::mutate(
#     first_PIT_tag = rfid_cols[1]
#   )
)
) %>%
glimpse()
# Starting the mapping earlier
test_list <- lags_df %>%
dplyr::mutate(
group_col = 1
) %>%
group_by(group_col) %>%
nest() %>%
# Lead differences, first PIT tag
dplyr::mutate(
runs_lead_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag1)[["lengths"]]) - (rle(binary_lead_tag1)[["lengths"]]),
li = cumsum(rle(binary_lead_tag1)[["lengths"]]),
vals = rle(binary_lead_tag1)[["values"]],
rl = rle(binary_lead_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, first PIT tag
dplyr::mutate(
runs_lag_tag1 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag1)[["lengths"]]) - (rle(binary_lag_tag1)[["lengths"]]),
li = cumsum(rle(binary_lag_tag1)[["lengths"]]),
vals = rle(binary_lag_tag1)[["values"]],
rl = rle(binary_lag_tag1)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# glimpse()
# Lead differences, second PIT tag
dplyr::mutate(
runs_lead_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lead_tag2)[["lengths"]]) - (rle(binary_lead_tag2)[["lengths"]]),
li = cumsum(rle(binary_lead_tag2)[["lengths"]]),
vals = rle(binary_lead_tag2)[["values"]],
rl = rle(binary_lead_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
# Lag differences, second PIT tag
dplyr::mutate(
runs_lag_tag2 = map(
.x = data,
.f = ~ dplyr::summarise(.x,
fi = cumsum(rle(binary_lag_tag2)[["lengths"]]) - (rle(binary_lag_tag2)[["lengths"]]),
li = cumsum(rle(binary_lag_tag2)[["lengths"]]),
vals = rle(binary_lag_tag2)[["values"]],
rl = rle(binary_lag_tag2)[["lengths"]]
) %>%
# If a first index is stored as 0, then add 1 to restore this first index
dplyr::mutate(
fi = ifelse(fi == 0, fi + 1, fi)
)
)
) %>%
ungroup() %>%
# Then do mapping to get the actual synchronized events for each nested data frame of lead and lag runs per PIT tag
# Lead differences, first PIT tag
dplyr::mutate(
tag_1_lead_syncs = map(
.x = runs_lead_tag1,
# Need to rename columns in order to apply the generalized function inside pmap_dfr
.y = data %>%
dplyr::rename(
`tag1_ts` = "leading_ts",
`tag2_ts` = !!sym(rfid_cols[2])
),
.f = ~ dplyr::filter(.x,
vals & rl >= run_length
) %>%
dplyr::select(fi, li, rl) %>%
pmap_dfr(find_syncs) %>%
dplyr::mutate(
first_PIT_tag = rfid_cols[1]
)
)
) %>%
glimpse()
