#' @title preprocess_detections
#' @description Pre-process raw radio frequency identification (RFID) and beam breaker data by thinning. Events detected by a single sensor are compared to each other, and adjacent events that occurred within a specified temporal threshold are filtered out. For RFID data, this data thinning is performed for each unique passive integrated transponder (PIT) tag in the dataset. For infrared beam breakers, the data thinning is carried out for each pair of beam breakers. This function still requires updates required for pre-processing video data
#' 
#' @param df A data frame with the following columns: year, month, day, a column containing information about the type of sensor, and a column with the timestamps of  detections by the given sensor TKTK. The function was written to accept data frames inside a list generated by splitting a larger data frame by sensor type (e.g. one data frame for either RFID, infrared beam breaker, or video data is used as input)
#' @param detection_col_nm A string with the column name for the detection timestamps collected by the given sensor. These timestamps must be in POSIXct or POSIXt format with millisecond resolution (e.g. format = "%Y-%m-%d %H:%M:%OS6")
#' @param group_col_nm A string with the column name that contains values used to group the data before pre-processing. The default is NULL. For RFID data, this column should contain the PIT tag identifiers, so that pre-processing is performed for each unique PIT tag. For beam breaker data, this column should be the unique beam breaker labels so that pre-processing is carried out separately for each beam breaker pair. When this argument is NULL, the input data will not be grouped prior to pre-processing
#' @param threshold A single numeric value representing a temporal threshold in seconds that will be used to thin the raw data

#' @return A data frame object with the pre-processed detections per sensor, all metadata columns in the original data frame, as well as a column indicating the temporal threshold used for pre-processing (in seconds). Each row of this data frame is a pre-processed detection from the raw data collected by the given sensor

# Testing
df <- pct_df3 %>% 
  dplyr::filter(data_type == "RFID") 

preprocess_detections <- function(df, detection_col_nm, group_col_nm = NULL, threshold){
  
  # Check that the raw data is a data frame
  if(!is.data.frame(df)){
    stop('The input object needs to be a data frame')
  }
  
  # Check that the temporal threshold is a number
  if(!is.numeric(threshold)){
    stop('The temporal threshold needs to be numeric (in seconds)')
  }
  
  # Check that the input dataset has the column of detections
  if(any(is.null(detection_col_nm) | !detection_col_nm %in% names(df))){
    stop('The column specified in `detection_col_nm` does not exist')
  }
  
  # Check that the input dataset has the grouping column, and does not have NAs
  if(any(!is.null(group_col_nm) | !group_col_nm %in% names(df) | any(is.na(df[[group_col_nm]])))){
    stop('The column specified in `group_col_nm` does not exist or has NA values')
  }
  
  # Check that the year, month, and day columns are also present in the data frame, and do not have NAs
  if(any(!"year" %in% names(df) | !"month" %in% names(df) | !"day" %in% names(df) | any(is.na(df[["year"]])) | any(is.na(df[["month"]])) | any(is.na(df[["day"]])))){
    stop('The data frame is missing columns `year`, `month`, or `day`, or there are NA values in one of these columns')
  }
  
  # Check that the timestamps are in the right format. This conditional also catches NAs in the RFID timestamps
  if(any(is.na(as.POSIXct(df[[detection_col_nm]], format = "%Y-%m-%d %H:%M:%OS6")))){
    stop('One or more timestamps are in the wrong format (need to be in POSIXct or POSIXt format, like %Y-%m-%d %H:%M:%OS6')
  }
  
  if(!is.null(group_col_nm)){
    
    tmp_df <- df %>%
      group_by(!!sym(group_col_nm)) %>%
      dplyr::arrange(event_datetime_ms, .by_group = TRUE) %>% 
      # Make unique row indices within groups
      dplyr::mutate(
        group_row_id = row_number()
      ) %>% 
      dplyr::rename(
        `group_col` = all_of(group_col_nm)
      )
    
  } else if(is.null(group_col_nm)){
    
    tmp_df <- df %>% 
      dplyr::arrange(event_datetime_ms) %>% 
      # Make unique row indices with the same column name as the group indices above
      dplyr::mutate(
        group_row_id = row_number()
      )
    
  }
  
  # If the group_col is specified, then the lags are calculated per group in the grouped data frame
  lags <- tmp_df %>% 
    dplyr::mutate(
      shift = dplyr::lag(event_datetime_ms, default = first(event_datetime_ms))
    ) %>% 
    # Convert differences to boolean based on a threshold to be able to remove stretches of detection events very close together
    dplyr::mutate(
      diff = floor(event_datetime_ms - shift),
      diff = as.numeric(diff),
      binary_diff = (diff >= threshold)
    ) 
  
  if(!is.null(group_col_nm)){
    lags <- lags %>% 
      dplyr::select(event_datetime_ms, group_col, diff, binary_diff) 
  } else {
    lags <- lags %>% 
      dplyr::select(event_datetime_ms, diff, binary_diff) 
  }
  
  # Nest by each group, do the rle calculations and removing indices, then recombine
  lags_runs <- lags %>% 
    dplyr::summarise(
      run_indices = cumsum(rle(binary_diff)[["lengths"]]),
      run_values = rle(binary_diff)[["values"]],
      run_lengths = rle(binary_diff)[["lengths"]]
    ) %>% 
    dplyr::filter(!run_values) 
  
  if(!is.null(group_col_nm)){
    
    lags_runs2 <- lags_runs %>% 
      dplyr::select(group_col, run_values, run_lengths, run_indices) %>% 
      pmap_dfr(., function(group_col, run_values, run_lengths, run_indices){
        # In the runs of FALSE values, remove all including the first index. Should work for all runs with length == 1 or > 1
        return(
          data.frame(
            group_col = group_col,
            rem_indices = seq((run_indices - (run_lengths - 1)), run_indices, 1)
          )
        )
      }) %>% 
      # Make sure to drop the first index per group, since these first observations should be retained
      dplyr::filter(rem_indices != 1)
    
    # Per group, remove the indices that represent the RFID detections which are too close together
    filt_df <- tmp_df %>% 
      nest() %>%
      # Filter each nested data frame by the correct row indices per group
      dplyr::mutate(
        filtered = map(.x = data, .f = ~ dplyr::filter(.x, !group_row_id %in% lags_runs2$rem_indices[group_col == lags_runs2$group_col]))
      ) %>% 
      # Return the filtered data frames as a single data frame
      unnest(`cols` = c(filtered)) %>% 
      dplyr::select(-c(data)) %>% 
      ungroup() %>% 
      # Make sure to add a column with the temporal threshold used
      dplyr::mutate(
        preProc_temporal_thresh = threshold
      )
    
    # Rename the group column back to its original name
    names(filt_df)[grep("group_col", names(filt_df))] <- group_col_nm
    
  } else {
    
    lags_runs2 <- lags_runs %>% 
      dplyr::select(run_values, run_lengths, run_indices) %>% 
      pmap_dfr(., function(run_values, run_lengths, run_indices){
        
        return(
          data.frame(
            rem_indices = seq((run_indices - (run_lengths - 1)), run_indices, 1)
          )
        )
      }) %>% 
      dplyr::filter(rem_indices != 1)
    
    
    filt_df <- tmp_df %>% 
      # Filter the data frame by the correct row indices
      dplyr::filter(!group_row_id %in% lags_runs2$rem_indices) %>% 
      # Remove the grouping column
      dplyr::select(-c(group_col)) %>% 
      # Make sure to add a column with the temporal threshold used
      dplyr::mutate(
        preProc_temporal_thresh = threshold
      )
    
  }
  
  return(filt_df)
  
}
