#' @title find_rfid_perching_events
#' @description Use the raw radio frequency identification (RFID) data to identify perching events (e.g. periods of time when an individual was perched on the RFID antenna). This function is performed for each unique passive integrated transponder (PIT) tag in the dataset. The function identifies runs of RFID detections separated by the given temporal threshold or less, then takes the first and last detection of each run and return these timestamps with start and end labels. Note that unlike the RFID pre-processing function, this function groups the data frame not only by PIT tag ID but also by date to avoid artificially long perching periods.
#' 
#' @param df A data frame with the following columns: year, month, day, a column containing RFID timestamps, and a column containing the PIT tag identities. The function is written to accept data frames inside a list generated by splitting a larger data frame by PIT tag ID (e.g. one data frame per PIT tag ID is used as input)
#' @param rfid_col_nm A string with the column name for the RFID event timestamps. These timestamps must be in POSIXct or POSIXt format with millisecond resolut (e.g. format = "%Y-%m-%d %H:%M:%OS6")
#' @param group_col_nm A string with the column name that contains PIT tag identifiers, so that perching events are identified for each unique PIT tag. This column name is used to group the data frame by unique PIT tags
#' @param threshold A single numeric value. This represents a temporal threshold in seconds that will be used to identify RFID detections that occurred in close succession (e.g. within 1 or 2 seconds) as perching events
#' @param run_length A single numeric value. This argument indicates the minimum number of consecutive RFID detections used to label a perching event. Default is 2   
#'
#' @return A data frame object with all metadata columns in the original data frame, as well as columns indicating the timestamp of the start of the perching period identified, the end of the given perching period, and the temporal threshold used for pre-processing (in seconds). In other words, each row is a perching period
#' 

find_rfid_perching_events <- function(df, rfid_col_nm, tag_id_col_nm, threshold, run_length = 2){
  
  # Check that the raw data is a data frame
  if(!is.data.frame(df)){
    stop('The input object needs to be a data frame')
  }
  
  # Check that the temporal threshold is a number
  if(!is.numeric(threshold)){
    stop('The temporal threshold needs to be numeric (in seconds)')
  }
  
  # Check that the input dataset has the column of RFID events, and do not have NAs
  if(!is.null(rfid_col_nm) & !rfid_col_nm %in% names(df) & !any(is.na(df[[rfid_col_nm]]))){
    stop('The column name specified in `rfid_col_nm` does not exist')
  }
  
  # Check that the input dataset has the PIT tag ID column, and does not have NAs
  if(!is.null(tag_id_col_nm) & !tag_id_col_nm %in% names(df) & !any(is.na(df[[tag_id_col_nm]]))){
  stop('The column name specified in `tag_id_col_nm` does not exist')
  }
  
  # Check that the year, month, and day columns are also present in the data frame, and do not have NAs
  if(!any(grepl("year|month|day", names(df))) & !any(is.na(df[["year"]])) & !any(is.na(df[["month"]])) & !any(is.na(df[["day"]]))){
    stop('The data frame is missing columns `year`, `month`, or `day`, or there are NA values in one of these columns')
  }
  
  # Check that the timestamps are in the right format
  if(any(is.na(as.POSIXct(df[[rfid_col_nm]], format = "%Y-%m-%d %H:%M:%OS6")))){
    stop('One or more timestamps are in the wrong format (need to be in %Y-%m-%d %H:%M:%OS6')
  }
  
  # Look for perching events by PIT tag ID and day. Otherwise the logic below ends up including the last event of a day and the first of the next day as the start and end indices, which leads to strangely long perching periods sometimes
  tmp_df <- df %>%
    dplyr::mutate(
      date = paste(year, month, day, sep = " - ")
    ) %>%
    group_by(date) %>%
    dplyr::arrange(!!sym(rfid_col_nm), .by_group = TRUE) %>% 
    # Make unique row indices within groups
    dplyr::mutate(
      group_row_id = row_number()
    ) %>% 
    dplyr::rename(
      `rfid_col` = all_of(rfid_col_nm) 
    )
  
  # The lags are calculated per group in the grouped data frame
  lags <- tmp_df %>% 
    dplyr::mutate(
      shift = dplyr::lag(rfid_col, default = first(rfid_col))
    ) %>% 
    # Convert differences to boolean based on a threshold to be able to remove stretches of detection events very close together
    dplyr::mutate(
      diff = floor(rfid_col - shift),
      diff = as.numeric(diff),
      binary_diff = (diff <= threshold) # Taking anything less than or equal to the threshold, see previous RFID pre-processing
    ) %>% 
    dplyr::select(date, rfid_col, diff, binary_diff) %>% 
    dplyr::rename(
      `dates` = "date"
    )
  
  # Make a data frame of the first and last indices of each run longer than 2 events that contain values below or equal to the given threshold
  lags_runs <- lags %>% 
    dplyr::summarise(
      first_indices = cumsum(rle(binary_diff)[["lengths"]]) - (rle(binary_diff)[["lengths"]] - 1),
      last_indices = cumsum(rle(binary_diff)[["lengths"]]),
      run_values = rle(binary_diff)[["values"]],
      run_lengths = rle(binary_diff)[["lengths"]]
    ) %>% 
    dplyr::filter(run_values & run_lengths >= run_length) %>% 
    ungroup()
  
  if(nrow(lags_runs) > 0){
    
    # Per group, retain the first and last indices of RFID detections flagged as perching events
    # For some reason nesting and subsequent filtering doesn't work with 2 group variables, even when these are pasted together (in an earlier version of the function), so I used pmap_dfr to iterate over rows in lags_runs instead
    filt_df <- lags_runs %>%
      dplyr::select(dates, first_indices, last_indices) %>% 
      pmap_dfr(., function(dates, first_indices, last_indices){
        
        starts <- tmp_df %>%
          ungroup() %>%
          dplyr::filter(date == dates) %>%
          slice(c(first_indices)) %>%
          pull(rfid_col)
        
        ends <- tmp_df %>%
          ungroup() %>%
          dplyr::filter(date == dates) %>%
          slice(c(last_indices)) %>%
          pull(rfid_col)
        
        return(data.frame(
          dates = dates,
          start = starts,
          end = ends,
          duration_seconds = as.numeric(ends - starts),
          event_type = "perching",
          run_length = run_length
        ))
        
      }) %>% 
      as_tibble() %>% 
      # Make sure to add a column with the temporal threshold used, and add back the tag ID column
      dplyr::mutate(
        temporal_threshold_seconds = threshold,
        PIT_tag_ID = df %>% 
          pull(!!sym(tag_id_col_nm)) %>% 
          unique()
      ) %>% 
      dplyr::select(
        dates,
        PIT_tag_ID,
        start,
        end,
        duration_seconds,
        event_type,
        temporal_threshold_seconds,
        run_length
      )
    
  } else {
    
    filt_df <- data.frame(
      dates = unique(tmp_df$date),
      PIT_tag_ID = df %>% 
        pull(!!sym(tag_id_col_nm)) %>% 
        unique(),
      start = NA,
      end = NA,
      duration_seconds = NA,
      event_type = NA,
      temporal_threshold_seconds = threshold,
      run_length = run_length
    )
    
  }
  
  return(filt_df)
  
}
