#' @title integrate_rfid_beamBreakers
#' @description Integrate pre-processed RFID and beam breaker data 
#' 
#' @param rfid_file_nm A character string. This argument should be the name and extension of the .csv file that contains all of the pre-processed RFID detections. Each row is a unique detection event. This spreadsheet must contain all the columns specified for the RFID data in the subsequent arguments.
#' @param irbb_file_nm A character string. This argument should be the name and extension of the .csv file that contains all of the pre-processed infrared beam breaker (IRBB) detections. Each row is a unique detection event. This data frame must contain all the columns specified for the IRBB data in the subsequent arguments.
#' @param l_th A numeric argument. This argument represents a lower or minimum temporal threshold in seconds to identify RFID and beam breaker events that are close enough together for integration.
#' @param u_th A numeric argument. This argument represents an upper or maximum temporal threshold in seconds to identify RFID and beam breaker events that are close enough together for integration.
#' @param sensor_id_col A character string. This argument is the name of the metadata column that contains information about the data type (e.g. "sensor_id").
#' @param timestamps_col A character string. The name of the column that contains timestamps in a format that supports calculations in milliseconds (e.g. "event_datetime_ms").
#' @param PIT_tag_col A character string. This argument is the name of the metadata column that contains information about the PIT tags detected by the RFID antenna (e.g. "PIT_tag_ID").
#' @param outer_irbb_col A character string. The column name that contains timestamps for the outer pair of beam breakers (e.g. the first pair of beam breakers that an animal encounters when moving into a nest container or area). The data format must also support calculations in milliseconds.
#' @param inner_irbb_col A character string. The column name that contains timestamps for the inner pair of beam breakers (e.g. the second pair of beam breakers that an individual encounters when moving into a nest container or area). The data format must also support calculations in milliseconds.
#' @param irbb_event_col A character string. The name of column that contains the type of beam breaker event (e.g. "entrance" or "exit).
#' @param irbb_unique_col A character string. The name of column that contains the unique numeric identifier for each beam breaker event.
#' @param preproc_metadata_cols A character vector. This argument should be a string of the metadata column names from pre-processing that should be dropped from either or both data frames. For instance, c("thin_threshold_s", "data_stage", "date_pre_processed", "lower_threshold_s", "upper_threshold_s", "date_labeled").
#' @param general_metadata_cols A character vector. This argument should be a string of the general metadata column names that will be carried through into the spreadsheet generated by this function. For instance: c("chamber_id", "year", "month", "day"). These columns will be added as the first columns in the integrated data frame, in the same order in which they are provided.
#' @param integrate_perching Boolean. If TRUE, then the perching events identified using `find_perching_events` will be integrated with this dataset. This integration is done by finding RFID timestamps that occurred within the duration of a perching event. If FALSE, then perching events will not be integrated. 
#' @param path A character string. This argument should be the path on the local computer or external hard drive specifying where the data is saved across sensors for a given experimental setup. For instance, "/media/gsvidaurre/Anodorhynchus/Data_Testing/Box_02_31Dec2022/Data".
#' @param data_dir A character string. This argument should be the name of the directory where the pre-processed RFID and the pre-processed, labeled beam breaker data is saved inside the path above. For instance, "pre-processed".
#' @param out_dir A character string. This argument should be the name of a directory specifying where the .csv file of integrated data should be saved. For instance, "integrated". This folder will be appended to the data_path and created as a new directory if it doesn't already exist.
#' @param out_file_nm A character string. The name (plus extension) of the resulting file that will be written to out_dir. The default is "integrated_rfid_beamBreaker_data.csv"
#' @param tz A character string. This argument should contain the timezone used for converting timestamps to POSIXct format. For instance, "America/New York". See the base function `as.POSIXct` for more information.
#' @param POSIXct_format A character string. This argument should contain the format used to converting timestamps to POSIXct format. The default is "%Y-%m-%d %H:%M:%OS6" to return timestamps with milliseconds in decimal format. See the base function `as.POSIXct` for more information.
#' 
#' @details This function uses lags between the pre-processed radio frequency identification (RFID) data and the pre-processed, labeled beam breaker data to integrate these two datasets. In the integrated dataset generated by this function, each RFID detection that remains is accompanied by a labeled event from the beam breaker dataset (e.g. an entrance or exit event). This function was written to integrate data across 1 RFID antenna and the outer pair of beam breakers (from the pre-processed and labeled beam breaker dataset) mounted around the entrance of a nest container, and will need to be updated/tested in order to integrate data collected with other types of hardware setups. This integration is done by finding RFID timestamps that occurred within the lower to upper thresholds after (entrances) or before (exits) the outer beam breaker. The integration was designed in this way to avoid the stricter matching imposed by expecting sequences of events in which the outer beam breakers, RFID antenna, and inner beam breakers triggered in that exact order, as the way in which birds arrive or perch in the entrance can lead to variation in this expected sequence). This integration function requires pre-processed and labeled beam breaker data, in which each outer beam breaker event was already matched to an inner beam breaker event and labeled with directionality. This function also integrates detections between datasets regardless of whether or not a given detection occurred during perching events captured by the RFID antenna (see `find_rfid_perching_events`). Some perching events may have started or ended as entrance or exit events, and it's important to retain those events at this stage. Perching event information can be returned by setting the argument `integrate_perching` to `TRUE`, which can subsequently be used to filter the integrated dataset as needed.
#' 
#' @return A spreadsheet in .csv format with the metadata columns from the original pre-processed data used as input, as well as columns indicating each of the timestamps of the RFID antenna, the lead and rear beam breaker pairs, a unique label for the given event (e.g. entrance or exit), a unique numeric identifier for the given event, and information about the given data processing stage. Each row in the .csv file is an RFID detection that was integrated with a labeled beam breaker event. Information about the temporal thresholds used for the integration and the date of integration is also contained in the resulting spreadsheet.
#' 

# rfid_file_nm = "test_rfid.csv"
# irbb_file_nm = "test_irbb.csv"
# l_th = 0
# u_th = 2
# sensor_id_col = "sensor_id"
# timestamps_col = "timestamps_ms"
# PIT_tag_col = "PIT_tag_ID"
# outer_irbb_col = "Outer_beam_breaker"
# inner_irbb_col = "Inner_beam_breaker"
# irbb_event_col = "irbb_direction_inferred"
# irbb_unique_col = "unique_entranceExit"
# preproc_metadata_cols = c("thin_threshold_s")
# general_metadata_cols = c("chamber_id", "year", "month", "day")
# path = "/home/gsvidaurre/Desktop"
# integrate_perching = FALSE
# data_dir = "tmp_tests"
# out_dir = "tmp_tests"
# out_file_nm = "integ_rfid_beamBreaker_testData.csv"
# tz = "America/New York"
# POSIXct_format = "%Y-%m-%d %H:%M:%OS"


integrate_rfid_beamBreakers <- function(rfid_file_nm, irbb_file_nm, l_th, u_th, sensor_id_col, timestamps_col, PIT_tag_col, outer_irbb_col, inner_irbb_col, irbb_event_col, irbb_unique_col, preproc_metadata_cols, general_metadata_cols, integrate_perching, path, data_dir, out_dir, out_file_nm = "integrated_rfid_beamBreaker_data.csv", tz, POSIXct_format = "%Y-%m-%d %H:%M:%OS"){
  
  # Get the current global options
  orig_opts <- options()
  
  # Set the number of digits for visualization. Under the hood there is full precision, but this helps for visual confirmation of decimal seconds
  options("digits.secs" = 6)
  
  # Get the user-specified values for each formal argument of the current function
  f_args <- getFunctionParameters()
  
  # Check that the formal arguments were all specified, and are not NULL or NA
  invisible(sapply(1:length(f_args), function(i){
    check_defined(f_args[i])
  }))
  
  # Check that the formal arguments that should be strings are strings
  expect_numeric <- c("l_th", "u_th")
  
  expect_bool <- c("integrate_perching")
  
  expect_strings <- f_args[-grep(paste(paste("^", c(expect_numeric, expect_bool), "$", sep = ""), collapse = "|"), names(f_args))]
  
  invisible(sapply(1:length(expect_strings), function(i){
    check_string(expect_strings[[i]])
  }))
  
  # Check that the formal arguments that should be numeric are numeric
  invisible(sapply(1:length(expect_numeric), function(i){
    check_numeric(f_args[[grep(paste(paste("^", expect_numeric[i], "$", sep = ""), collapse = "|"), names(f_args))]])
  }))
  
  # Check that the formal arguments that should be Boolean are Boolean
  invisible(sapply(1:length(expect_bool), function(i){
    check_boolean(f_args[[grep(paste(paste("^", expect_bool[i], "$", sep = ""), collapse = "|"), names(f_args))]])
  }))
  
  # Check that the input directory exists
  check_dirs(path, data_dir)
  
  # Check that the input files exist in the input directory
  check_file(file.path(path, data_dir), rfid_file_nm)
  check_file(file.path(path, data_dir), irbb_file_nm)
  
  # Create the directory for saving the integrated data files if it doesn't already exist
  if(!dir.exists(file.path(path, out_dir))){
    dir.create(file.path(path, out_dir))
  }
  
  # Read in the pre-processed RFID data
  preproc_rfid <- read.csv(file.path(path, data_dir, rfid_file_nm)) %>% 
    # Make sure that the timestamps are in the right format
    dplyr::mutate(
      !!timestamps_col := as.POSIXct(format(as.POSIXct(!!sym(timestamps_col), tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
    ) 
  
  # Read in the pre-processed and labeled beam breaker data
  labeled_irbb <- read.csv(file.path(path, data_dir, irbb_file_nm)) %>% 
    # Make sure that the timestamps are in the right format
    dplyr::mutate(
      !!outer_irbb_col := as.POSIXct(format(as.POSIXct(!!sym(outer_irbb_col), tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
      !!inner_irbb_col := as.POSIXct(format(as.POSIXct(!!sym(inner_irbb_col), tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
    )
  
  # Drop columns that aren't needed here for both datasets
  rfid_cols2drop <- names(preproc_rfid)[grep(paste(paste("^", preproc_metadata_cols, "$", sep = ""), collapse = "|"), names(preproc_rfid))]
  
  irbb_cols2drop <- names(labeled_irbb)[grep(paste(paste("^", preproc_metadata_cols, "$", sep = ""), collapse = "|"), names(labeled_irbb))]
  
  preproc_rfid2 <- preproc_rfid %>% 
    dplyr::select(-c(all_of(rfid_cols2drop)))
  
  labeled_irbb2 <- labeled_irbb %>% 
    dplyr::select(-c(all_of(irbb_cols2drop)))
  
  # Check that these objects are both data frames
  check_df_class(preproc_rfid2)
  check_df_class(labeled_irbb2)
  
  # Check that the expected columns from formal arguments are found in each data frame
  colnames_fArgs <- f_args[grep("col", names(f_args))][-grep("preproc_metadata_cols", names(f_args[grep("col", names(f_args))]))]
  
  rfid_expected_cols <- colnames_fArgs[grep(paste(c("sensor", "time", "PIT"), collapse = "|"), names(colnames_fArgs))]
  
  irbb_expected_cols <- colnames_fArgs[-grep(paste(names(rfid_expected_cols), collapse = "|"), names(colnames_fArgs))]
  
  invisible(sapply(1:length(rfid_expected_cols), function(i){
    check_fArgs_data_cols(rfid_expected_cols[[i]], preproc_rfid2)
  }))
  
  invisible(sapply(1:length(irbb_expected_cols), function(i){
    check_fArgs_data_cols(irbb_expected_cols[[i]], labeled_irbb2)
  }))
  
  # Also do this check for their earlier version of the beam breaker events that will be used for writing out general metadata
  invisible(sapply(1:length(general_metadata_cols), function(i){
    check_fArgs_data_cols(general_metadata_cols[i], labeled_irbb)
  }))

  # Check that the expected columns from formal arguments do not have NAs
  invisible(sapply(1:length(rfid_expected_cols), function(i){
    check_fArgs_cols_nas(rfid_expected_cols[[i]], preproc_rfid2)
  }))
  
  invisible(sapply(1:length(irbb_expected_cols), function(i){
    check_fArgs_cols_nas(irbb_expected_cols[[i]], labeled_irbb2)
  }))
  
  # Check that date-related columns are found in the data
  expected_cols <- c("year", "month", "day")
  
  invisible(sapply(1:length(expected_cols), function(i){
    check_data_cols(expected_cols[i], preproc_rfid2)
  }))
  
  invisible(sapply(1:length(expected_cols), function(i){
    check_data_cols(expected_cols[i], labeled_irbb2)
  }))
  
  # Check that the date-related columns do not have NAs
  invisible(sapply(1:length(expected_cols), function(i){
    check_cols_nas(expected_cols[i], preproc_rfid2)
  }))
  
  invisible(sapply(1:length(expected_cols), function(i){
    check_cols_nas(expected_cols[i], labeled_irbb2)
  }))
  
  # Check that columns with timestamps are in the right format
  check_tstmps_cols("timestamps_col", preproc_rfid2, "%Y-%m-%d %H:%M:%OS6")
  
  tstmps_cols <- c("outer_irbb_col", "inner_irbb_col")
  
  invisible(sapply(1:length(tstmps_cols), function(i){
    check_tstmps_cols(tstmps_cols[i], labeled_irbb2, "%Y-%m-%d %H:%M:%OS6")
  }))
  
  # Group the RFID data frame
  rfid_df_tmp <- preproc_rfid2 %>% 
    group_by(!!sym(PIT_tag_col)) %>% 
    dplyr::rename(
      `group_col` = all_of(PIT_tag_col)
    ) %>%
    nest()
  
  # Get the sensor ID value for the RFID data, which will be a column name below
  rfid_col <- preproc_rfid2 %>% 
    pull(sensor_id) %>% 
    unique()
  
  # Lengthen the IRBB data frame. Make sure this has the same columns in the same order as the RFID data for the row binding and calculations below
  irbb_df_tmp <- labeled_irbb2 %>% 
    pivot_longer(
      cols = c(all_of(outer_irbb_col), all_of(inner_irbb_col)),
      names_to = sensor_id_col,
      values_to = timestamps_col
    ) %>% 
    dplyr::mutate(
      group_col = NA
    ) %>% 
    dplyr::select(names(rfid_df_tmp$data[[1]]))
  
  # Do the timestamp difference calculations
  lags_grpd <- rfid_df_tmp %>% 
    dplyr::mutate(
      # Here the mapping structure sets up running the following code for each group (PIT taq ID) in the RFID data frame
      lags = map(
        .x = data,
        # Here I'm interested in aligning to the outer pair of beam breakers only
        .y = irbb_df_tmp %>%
          dplyr::filter(!!sym(sensor_id_col) == outer_irbb_col),
        .f = ~ bind_rows(.x, .y) %>%
          as_tibble() %>%
          # Order timestamps within each data type
          group_by(!!sym(sensor_id_col)) %>% 
          dplyr::arrange(!!sym(timestamps_col), desc = FALSE) %>%
          # Make unique row indices within groups
          dplyr::mutate(
            group_row_id = row_number()
          ) %>%
          ungroup() %>% 
          pivot_wider(
            names_from = all_of(sensor_id_col),
            values_from = all_of(timestamps_col)
          ) %>% 
          # Make a leading and lagging RFID column for calculations and filtering below. Lead() moves the RFID timestamps one row index up, and lag() moves these timestamps one row index down
          dplyr::mutate(
            leading_RFID = lead(!!sym(rfid_col), default = first(!!sym(rfid_col))),
            lagging_RFID = lag(!!sym(rfid_col), default = first(!!sym(rfid_col)))
          ) %>% 
          # Calculate the differences between the relevant pairs of timestamps: RFID compared to the outer beam breaker pair to find entrances and exits
          # The lags are calculated per group in the grouped data frame
          dplyr::mutate(
            # For both the lagging and leading calculations, negative differences mean that the RFID antenna triggered first, while positive differences mean that outer beam breaker pair triggered first
            outer_rfid_lead_diffs = round(as.numeric(leading_RFID - !!sym(outer_irbb_col)), 2),
            outer_rfid_lag_diffs = round(as.numeric(lagging_RFID - !!sym(outer_irbb_col)), 2)
          ) %>%
          # Convert these differences to Boolean values based on a threshold (in seconds). Inverting these conditionals to match the negative differences that should indicate an entrance event
          dplyr::mutate(
            # To search for entrances, look for RFID detections that came within the given l_th or u_th AFTER an outer beam breaker timestamp. Set up these conditionals for both the lead and lag calculations
            binary_lead_outer_ent = (
              # RFID after, so positive differences
              outer_rfid_lead_diffs >= l_th & outer_rfid_lead_diffs <= u_th
            ),
            binary_lag_outer_ent = (
              # RFID after, so positive differences
              outer_rfid_lag_diffs >= l_th & outer_rfid_lag_diffs <= u_th
            ),
            # Then to search for exits, look for RFID detections that came within the given l_th or u_th BEFORE an outer beam breaker timestamp. Again, set up these conditionals for both the lead and lag calculations
            binary_lead_outer_exi = (
              # RFID before, so negative differences
              outer_rfid_lead_diffs <= -l_th & outer_rfid_lead_diffs >= -u_th
            ),
            binary_lag_outer_exi = (
              # RFID before, so negative differences
              outer_rfid_lag_diffs <= -l_th & outer_rfid_lag_diffs >= -u_th
            )
          ) %>% 
          # Drop all rows with NA values across these binary columns
          dplyr::filter(
            !dplyr::if_all(
              c(
                binary_lead_outer_ent,
                binary_lag_outer_ent,
                binary_lead_outer_exi,
                binary_lag_outer_exi
              ), 
              is.na
            )
          ) %>% 
          # Add back metadata about the beam breaker event labels
          dplyr::inner_join(
            labeled_irbb2 %>%
              dplyr::select(all_of(outer_irbb_col), all_of(irbb_event_col)),
            by = c(all_of(outer_irbb_col))
          )
      )
    )
  
  conditnal_lead_ent <- "binary_lead_outer_ent & !is.na(binary_lead_outer_ent)"
  conditnal_lead_exi <- "binary_lead_outer_exi & !is.na(binary_lead_outer_exi)"
  
  conditnal_lag_ent <- "binary_lag_outer_ent & !is.na(binary_lag_outer_ent)"
  conditnal_lag_exi <- "binary_lag_outer_exi & !is.na(binary_lag_outer_exi)"
  
  # Do more mapping to perform the integration depending on the given lower and upper temporal thresholds
  # This is done per PIT tag, and the integration is done separately for entrances and exits from each of the leading and lagging calculations
  integr8d_df <- lags_grpd %>% 
    dplyr::mutate(
      # Entrances, lead differences
      matched_irbb_rfid = map(
        .x = lags, 
        .f = ~ dplyr::mutate(
          .x,
          !!rfid_col := leading_RFID,
          outer_rfid_diffs = outer_rfid_lead_diffs,
          rfid_irbb_assignmnt_type = "lead"
        ) %>% 
          # Filter for entrances among the labeled beam breaker events 
          dplyr::filter(
            !!sym(irbb_event_col) == "entrance"
          ) %>% 
          # Then filter for RFID detections that match these beam breaker events
          dplyr::filter(
            !!rlang::parse_expr(conditnal_lead_ent)
          ) %>% 
          dplyr::select(all_of(outer_irbb_col), all_of(rfid_col), outer_rfid_diffs, rfid_irbb_assignmnt_type)
        %>%
          # Entrances, lag differences
          bind_rows(
            .x %>%
              dplyr::mutate(
                !!rfid_col := lagging_RFID,
                outer_rfid_diffs = outer_rfid_lag_diffs,
                rfid_irbb_assignmnt_type = "lag"
              ) %>%
              # Filter for entrances among the labeled beam breaker events 
              dplyr::filter(
                !!sym(irbb_event_col) == "entrance"
              ) %>% 
              # Then filter for RFID detections that match these beam breaker events
              dplyr::filter(
                !!rlang::parse_expr(conditnal_lag_ent)
              ) %>%
              dplyr::select(all_of(outer_irbb_col), all_of(rfid_col), outer_rfid_diffs, rfid_irbb_assignmnt_type)
          ) %>%
          # Exits, lead differences
          bind_rows(
            .x %>%
              dplyr::mutate(
                !!rfid_col := leading_RFID,
                outer_rfid_diffs = outer_rfid_lead_diffs,
                rfid_irbb_assignmnt_type = "lead"
              ) %>%
              # Filter for exits among the labeled beam breaker events 
              dplyr::filter(
                !!sym(irbb_event_col) == "exit"
              ) %>% 
              # Then filter for RFID detections that match these beam breaker events
              dplyr::filter(
                !!rlang::parse_expr(conditnal_lead_exi)
              ) %>%
              dplyr::select(all_of(outer_irbb_col), all_of(rfid_col), outer_rfid_diffs, rfid_irbb_assignmnt_type)
          ) %>%
          # Exits, lag differences
          bind_rows(
            .x %>%
              dplyr::mutate(
                !!rfid_col := lagging_RFID,
                outer_rfid_diffs = outer_rfid_lag_diffs,
                rfid_irbb_assignmnt_type = "lag"
              ) %>%
              # Filter for exits among the labeled beam breaker events 
              dplyr::filter(
                !!sym(irbb_event_col) == "exit"
              ) %>% 
              # Then filter for RFID detections that match these beam breaker events
              dplyr::filter(
                !!rlang::parse_expr(conditnal_lag_exi)
              ) %>%
              dplyr::select(all_of(outer_irbb_col), all_of(rfid_col), outer_rfid_diffs, rfid_irbb_assignmnt_type)
          )
      )
    ) %>% 
    dplyr::select(-c(data, lags)) %>% 
    unnest(`cols` = c(matched_irbb_rfid)) %>%
    ungroup() %>% 
    # Make sure to add metadata columns for this integration step
    dplyr::mutate(
      data_stage = "integration",
      rfid_irbb_lower_threshold_s = l_th,
      rfid_irbb_upper_threshold_s = u_th,
      date_integrated = paste(Sys.Date(), Sys.time(), sep = " ")
    ) %>% 
    dplyr::rename(
      !!PIT_tag_col := `group_col`
    ) %>% 
    # Add back metadata about the beam breaker events and general metadata
    dplyr::inner_join(
      labeled_irbb %>%
        dplyr::select(all_of(general_metadata_cols), all_of(outer_irbb_col), all_of(inner_irbb_col), all_of(irbb_event_col), all_of(irbb_unique_col)),
      by = c(all_of(outer_irbb_col))
    ) %>%
    dplyr::select(all_of(general_metadata_cols), all_of(rfid_col), all_of(outer_irbb_col), all_of(inner_irbb_col), all_of(PIT_tag_col), all_of(irbb_event_col), all_of(irbb_unique_col), outer_rfid_diffs, rfid_irbb_assignmnt_type, data_stage, rfid_irbb_lower_threshold_s, rfid_irbb_upper_threshold_s, date_integrated) %>% 
    dplyr::arrange(!!sym(rfid_col), desc = FALSE)
  
  # There may be duplicated timestamps if RFID detections were assigned to pre and post video recording events. Given the way the lags were calculated, it isn't possible to find these duplicates using the columns of binary values. Find these duplicates and retain only the pre-video recording event
  dup_inds <- which(duplicated(integr8d_df[[rfid_col]]))
  
  if(length(dup_inds) > 0){
    
    # Return the rows to retain
    tmp_df <- data.table::rbindlist(lapply(1:length(dup_inds), function(i){
      
      # For each RFID timestamp that is present more than once, retain the integrated event that represents the closest match (e.g. the smallest temporal difference) between the RFID and outer beam breaker timestamps
      tmp_dup <- integr8d_df %>% 
        slice(dup_inds[i]) %>% 
        pull(!!sym(rfid_col))
      
      return(
        integr8d_df %>% 
          dplyr::filter(
            !!sym(rfid_col) == tmp_dup
          ) %>% 
          dplyr::arrange(-desc(abs(outer_rfid_diffs))) %>% 
          slice(1)
      )
      
    }))
    
    # Get the indices of all of the duplicated rows
    all_dup_inds <- unlist(lapply(1:length(dup_inds), function(i){
      
      tmp_dup <- integr8d_df %>% 
        slice(dup_inds[i]) %>% 
        pull(!!sym(rfid_col))
      
      return(
        integr8d_df %>% 
          rowid_to_column() %>% 
          dplyr::filter(
            !!sym(rfid_col) == tmp_dup
          ) %>% 
          pull(rowid)
      )
      
    }))
    
    # Remove all of the duplicated rows, then add back the rows to retain
    integr8d_df_noDups <- integr8d_df %>% 
      slice(-c(all_dup_inds)) %>% 
      bind_rows(
        tmp_df
      ) %>% 
      dplyr::arrange(!!sym(rfid_col), desc = FALSE)
    
  } else {
    integr8d_df_noDups <- integr8d_df
  }
  
  # Integrate perching events if specified
  if(integrate_perching){
    
    perch_df <- read.csv(file.path(path, data_dir, "perching_events.csv"))  %>% 
      # Make sure that the timestamps are in the right format
      dplyr::mutate(
        perching_start = as.POSIXct(format(as.POSIXct(perching_start, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6")),
        perching_end = as.POSIXct(format(as.POSIXct(perching_end, tz = "America/New York"), "%Y-%m-%d %H:%M:%OS6"))
      )
    
    if(nrow(perch_df) > 0){
      
      # For each integrated detection, figure out whether it occurred during a perching event and add that perching event to the integrated dataset
      # Rename the column of RFID timestamps in the integrated dataset so that the column name can be passed to the function call in pmap_dfr
      integr8d_df_noDups <- integr8d_df_noDups %>% 
        dplyr::rename(
          `rfid_col` = !!sym(rfid_col)
        )
      
      tmp_df <- integr8d_df_noDups %>% 
        dplyr::select(rfid_col) %>% 
        pmap_dfr(., function(rfid_col){
          
          tmp_perching <- perch_df %>% 
            dplyr::filter(
              rfid_col >= perching_start & rfid_col <= perching_end 
            ) %>% 
            dplyr::mutate(
              rfid_col = rfid_col
            ) %>% 
            dplyr::select(rfid_col, all_of(PIT_tag_col), perching_start, perching_end, perching_duration_s, unique_perching_event)
          
          return(tmp_perching)
          
        })
      
      # Then join this data frame of perching event assignments with the integrated dataset
      integr8d_df_noDups_p <- integr8d_df_noDups %>% 
        dplyr::full_join(
          tmp_df,
          by = c("rfid_col", all_of(PIT_tag_col))
        ) %>% 
        # Rename the RFID timestamps column
        dplyr::rename(
          !!rfid_col := "rfid_col"
        ) %>% 
        dplyr::select(names(.)[-grep("^data_stage$|^date_integrated$", names(.))], "data_stage", "date_integrated")
    
    } else {
      
      warning("The perching events dataset was empty; skipping integration of perching events")
      integr8d_df_noDups_p <- integr8d_df_noDups
      
    }
    
  } else {
    
    integr8d_df_noDups_p <- integr8d_df_noDups
    
  }
  
  write.csv(integr8d_df_noDups_p, file.path(path, out_dir, out_file_nm), row.names = FALSE)
  
  # Reset the current global options
  options(orig_opts)
  
}
